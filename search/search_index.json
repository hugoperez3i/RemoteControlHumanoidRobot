{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"Telerobotic Platform:         Remote Control of a Humanoid Robot    <p>This project features a telerobotic platform designed for the remote operation of robots. It follows an orchestrator system architecture in which a central server receives commands from remote clients and routes them to the selected robot. </p> <p>Communications between nodes are handled through a custom, lightweight, application-layer protocol focused on clarity and functionality, minimizing overhead while remaining human-readable and easily extendable.</p> <p>The platform includes two client-side implementations. The first one is a fully developed JavaFX application, offering a streamlined graphical interface for direct robot control. The second is a custom Unreal Engine 5 module that integrates into UE5 projects using a blueprint-friendly interface, enabling real-time robotic control from within Unreal-based projects.</p> <p>To sum it up:</p> <ul> <li>Orchestrator-based platform</li> <li>Lightweight, human-readable custom protocol</li> <li>JavaFX GUI Client</li> <li>UE5 Control module with native Blueprint integration</li> </ul> <p>This project merges the work of both my Telecommunications Systems Engineering and Biomedical Engineering bachelor\u2019s theses, combining system-level communications design with applied robotics in a single, complete platform.</p>"},{"location":"Application%20Protocol/Control%20Query/","title":"Control Query","text":"<p>The positive (ACK) and negative (NACK) control queries let the client know whether a requested action was successful or not. In case of failure, NACKs also provide context on what went wrong or where the error occurred.</p> <p>These queries follow the standard protocol structure, using <code>_ACK</code> and <code>NACK</code> as their 4-byte function codes. They include a single byte <code>c</code> as the error code (for positive control queries, <code>c</code> will take always the value <code>uint8_t c=255</code>)..</p> Positive (Acknowledge) QueryNegative (No Acknowledge) Query <pre><code>!s-_ACK-c-e!\n</code></pre> <pre><code>!s-NACK-c-e!\n</code></pre> <p>As such, the communication schema in which these queries will be used will look like the one illustrated on the following diagram.</p>"},{"location":"Application%20Protocol/Execution%20Mode/","title":"Execution Mode","text":"<p>eMOD</p>"},{"location":"Application%20Protocol/Identification%20Query/","title":"Identification Query","text":"<p>The login or identification query informs the server of the type of node initiating the connection, whether it's a client or an mcu.</p> <p>This query poses an exception from the <code>4-byte code</code> structure, though it still follows the overall query structure. Instead of using said code, it relies on two constant sequences <code>Client_here</code> and <code>NodeMCU_here</code>, which represent the client node and mcu nodes respectively.</p> <p>This query has a different behaviour depending on whether it was successful or not. When it succeeds, the server will send no reponse and, on failure, the server will reply with a control query containing an error code identifying the error.  The possible error codes that may be returned by the server are:</p> <ul> <li><code>_NACK_InvalidQuery</code> (<code>uint8_t c=255</code>) \u2192 If the query format is invalid: contains null-bytes, invalid header or tail sequences, or the query does not follow the structure for the client or mcu login queries.</li> </ul>"},{"location":"Application%20Protocol/Identification%20Query/#client-login-query","title":"Client Login Query","text":"<p>The client login query is very straightfoward: The client sends the login query and, assuming there's no unexpected/unknown errors on server-side, the client will be logged to the server successfully. Otherwise, a negative control query will be returned, and the connection will be closed.</p> <p>The login query is a constant sequence of characters with the form: <code>!s-Client_here-e!</code>.</p> Diagram for a successful and failed client login query"},{"location":"Application%20Protocol/Identification%20Query/#mcu-login-query","title":"MCU Login Query","text":"<p>On the other hand, the mcu login query is a little bit more complex. The query will follow a structure similar to the client one, using the constant sequence <code>!s-NodeMCU_here-[info]-e!</code> but with an additional information field, <code>[info]</code>, added to the message. This additional field will contain information about the mcu, such as the unique id or name, used to identify the mcu; the number of servos, which indicates how many servos the mcu has; and either a fixed byte value (<code>uint8_t c=187</code>), if the mcu is of the type DumbMCU; or the current position of each of the mcu servos, if the mcu is of the type SmartMCU.</p> SmartMCU Login QueryDumbMCU Login Query <pre><code>!s-NodeMCU_here-[MCU_UNIQUE_NAME]-[SERVO_COUNT]-[SERVOPOS(0)]-&lt;...&gt;-[SERVOPOS(SERVO_COUNT-1)]-e!\n</code></pre> <ul> <li><code>[MCU_UNIQUE_NAME]</code> \u2192 The unique id used to identify the mcu (<code>char[]</code>).</li> <li><code>[SERVO_COUNT]</code> \u2192 A single <code>uint8_t</code> indicating how many servos the mcu has. Since this number cannot be zero, it does not need any offset applied.</li> <li><code>[SERVOPOS(i)]</code> \u2192 The position of each mcu servo (as a <code>uint8_t</code>), with a dash <code>-</code> between each of them, and ordered by ascending servo ID. Since this value can be zero (0-179 range), by protocol it needs to be offset by +1.</li> </ul> <pre><code>!s-NodeMCU_here-[MCU_UNIQUE_NAME]-[SERVO_COUNT]-[187]-e!\n</code></pre> <ul> <li><code>[MCU_UNIQUE_NAME]</code> \u2192 The unique id used to identify the mcu (<code>char[]</code>).</li> <li><code>[SERVO_COUNT]</code> \u2192 A single <code>uint8_t</code> indicating how many servos the mcu has. Since this number cannot be zero, it does not need any offset applied.</li> <li><code>[187]</code> \u2192 The byte <code>uint8_t b=187</code>. Indicates the server that the mcu is of the type DumbMCU.</li> </ul> Diagram for a successful and failed mcu login query"},{"location":"Application%20Protocol/MCU%20Information/","title":"MCU Information","text":"<p>iMCU</p>"},{"location":"Application%20Protocol/Protocol%20Definition/","title":"Protocol Definition","text":"<p>The application protocol runs over a persistent socket connection through the TCP/IP stack. Since it relies on TCP for several of its core behaviors, it's recommended, but not required, to disable Nagle's Algorithm by enabling the TCP_NODELAY socket option; and to enable the TCP keepalive with an aggressive setting. By default, the protocol uses port <code>TCP:54817</code>.</p>"},{"location":"Application%20Protocol/Protocol%20Definition/#architecture-components","title":"Architecture Components","text":"<p>The protocol contemplates three types of nodes: client, server and mcu.</p> <ul> <li>Client: Refers to the remote user, which can control a mcu.</li> <li>Server: Refers to the orchestrator service, in charge of query validation and routing client queries to the indicated MCU. </li> <li>MCU: Refers to the remote robotic system, which may be remotely operated by a client.</li> </ul>"},{"location":"Application%20Protocol/Protocol%20Definition/#client-role","title":"Client Role","text":"<p>The client is the only proactive node in the architecture: it sends commands to the server, which either relays them to the mcu or handles them directly before replying with a control response.</p>"},{"location":"Application%20Protocol/Protocol%20Definition/#server-role","title":"Server Role","text":"<p>The server acts as the orchestrator in this architecture. Its functions are routing and validation, interconnecting each client with the mcu it intends to control, and validating the parameters sent by the client before relaying them to the mcu for execution. The server will never send any message to the client or mcu unless prompted by a client query.</p>"},{"location":"Application%20Protocol/Protocol%20Definition/#mcu-role","title":"MCU Role","text":"<p>The mcu is the passive executor node, responsible solely for carrying out orders received from the server. On startup, it sends a login message to the server, then waits for incoming commands, executes them, and replies with an ACK control message.</p>"},{"location":"Application%20Protocol/Protocol%20Definition/#mcu-types","title":"MCU Types","text":"<p>The protocol contemplates two types of MCU robotic systems:</p> <ul> <li>SmartMCU: Refers to a mcu that is capable of generating its own PWM signal values for a given position. This means that a SmartMCU must be able to store locally the PWM calibration values, it also needs to be capable of storing pending movements, and will be required to, on connection, send the current position of each of its servos.</li> <li>DumbMCU: Refers to a mcu that executes movements by reading the PWM signal value directly from the query. This means that a DumbMCU will not receive any information until a movement is expected to be executed, at which point, it will receive a query with the PWM signal value for each servo, instead of a servo position (0\u00ba-179\u00ba). On connection, a DumbMCU is required to send the number of servos it has. </li> </ul>"},{"location":"Application%20Protocol/Protocol%20Definition/#no-binary-zero-convention","title":"No binary zero convention","text":"<p>In order to avoid potential issues with the zero-value bytes (<code>uint8_t b=0</code>), every numerical field that could possibly take the value zero gets offset by +1. This means that fields such as <code>servoId</code> (range 0-31) and <code>servoPosition</code> (range 0-179) will be sent with a +1 positive offset applied: <code>servoId</code> would take the range (1-32) and <code>servoPosition</code> the range (1-180).</p>"},{"location":"Application%20Protocol/Protocol%20Definition/#protocol-query-format","title":"Protocol Query Format","text":"<p>The protocol distinguishes two types of query formats: A client - server format, and a server - mcu format. These two formats were defined to improve the clarity of the protocol, making it obvious which part of the communication chain a given query belongs to. However, the login query poses an exception to these formats, where client and mcu have a unique query style, also different from the other query formats.</p> <p>The protocol query uses plain, raw binary, with no codification or encryption. All format and structure characters are standard ASCII.</p>"},{"location":"Application%20Protocol/Protocol%20Definition/#client-server-query-format","title":"Client - Server Query Format","text":"<p>The message follows a set structure: it always starts with a constant header, <code>!s-</code>, followed by a 4-byte function selector code <code>CODE</code>, and is terminated by a constant tail <code>-e!</code>. This structure can accommodate additional information, for those functions that require it: the information will be added behind the four-byte function selector code (<code>CODE</code>), separated with an additional slash <code>-</code>.</p> No additional informationContaining additional information <pre><code>!s-CODE-e!\n</code></pre> <pre><code>!s-CODE-[ADDITIONAL_INFORMATION]-e!  \n</code></pre> <p>This means that the minimum query length will be <code>11</code> bytes (3 from the header <code>!s-</code>, +4 from the selection code <code>CODE</code>, and +3 from the tail sequence <code>-e!</code>). Any query with less than <code>11 bytes</code> can be safely deleted, as it would mean that some kind of error happened during query formation.</p>"},{"location":"Application%20Protocol/Protocol%20Definition/#server-mcu-query-format","title":"Server - MCU Query Format","text":"<p>Similarly to the client - server query, the server - mcu query also uses an structured format with header and tail. However, in this second format, the header is reduced to a single <code>-</code>, while the tail sequence takes the form <code>-!</code>. The 4-byte function selector code becomes a single-byte code <code>c</code>, and the additional information, when needed, is added in the exact same format as the client - server format: behind the single-byte code <code>c</code>, and separated with a dash character <code>-</code>.</p> No additional informationContaining additional information <pre><code>-c-!\n</code></pre> <pre><code>-c-[ADDITIONAL_INFORMATION]-!\n</code></pre>"},{"location":"Application%20Protocol/Robot%20Selection/","title":"MCU Selection","text":"<p>The robot selection query ...</p> <pre><code>!s-sMCU-[MCU_UNIQUE_NAME]-e!\n</code></pre> <p>The possible query responses are ...</p> <p>As such, the communication schema for this query type will look like the one illustrated on the following diagram.</p> Diagram for a successful and failed mcu selection query"},{"location":"Application%20Protocol/Server%20Shutdown/","title":"Server Shutdown","text":"<p>The server shutdown query ...</p> <pre><code>!s-sOFF-e!\n</code></pre> <p>As such, the communication schema for this query type will look like the one illustrated on the following diagram.</p>"},{"location":"Application%20Protocol/Servo%20Movement/","title":"Servo Movement","text":"<p>SRVP</p>"},{"location":"Application%20Protocol/Upload%20Information/","title":"Upload Information","text":"<p>UINF</p>"},{"location":"demos/Demo%20Showcase/","title":"Demo Showcase: Scripted actions","text":"<p>A simple showcase of the telerobotic platform working, in which the Youbionic Half performs a scripted movement.</p>"},{"location":"demos/Demo%20Showcase/#showcase-video","title":"Showcase Video","text":""},{"location":"demos/Demo%20Showcase/#demo-walkthrough","title":"Demo walkthrough","text":"<p>This demo intends to show how the platform operates. For this task, a simple client is used to control the Youbionic Half robot, and perform a series of scripted movements that resemble the action of looking towards your hand, opening and closing it, and then get back to your original position.</p>"},{"location":"demos/Demo%20Showcase/#server-connection","title":"Server Connection","text":"<p>The first part of the cpp script, available on the next section, creates a client that connects to a given IP at the predefined port <code>57573</code>:</p> <pre><code>/* Start connection */\nClient c(ip);\n    usleep(500000);\n</code></pre>"},{"location":"demos/Demo%20Showcase/#robot-selection","title":"Robot Selection","text":"<p>Then the script selects the robot it wants to control, in this case Maroon - the ID used by the Youbionic Half robot in our setup, using the <code>connectToMCU()</code> function:</p> <pre><code>/* Select the mcu to control */\nstd::cout&lt;&lt;c.connectToMCU(\"Maroon\") &lt;&lt;\"\\n\";\n    usleep(2500000); // Wait 2.5 seconds\n</code></pre>"},{"location":"demos/Demo%20Showcase/#movement-configuration-and-execution","title":"Movement Configuration and Execution","text":"<p>For each movement, the client needs to generate a <code>std::vector&lt;int&gt;</code> in which to store the desired movements. For this client implementation, a <code>uint32_t flag</code> bitmask is also needed. This flag serves as an efficient way of indicating <code>moveServos()</code> the IDs of the servos that we want to move.</p> <p><pre><code>/* Combined movement 1 - Rise hand towards face, tilt head */\nstd::vector&lt;int&gt; pV1;{\n    flag=0;\n    pV1.push_back(0); // rotate palm towards face\n    flag = (flag | (1&lt;&lt;13)); \n    pV1.push_back(0); // flex arm towards face\n    flag = (flag | (1&lt;&lt;15)); \n    pV1.push_back(100); // Rotate arm towards body\n    flag = (flag | (1&lt;&lt;17)); \n    pV1.push_back(179); // Tilt head towards hand\n    flag = (flag | (1&lt;&lt;25)); \n    pV1.push_back(141); // Rotate head towards hand\n    flag = (flag | (1&lt;&lt;26)); \n}\n</code></pre> Lastly, the <code>moveServos()</code> function is used to send the movement order to the server, which will validate it and provide a two-step response (assuming it passes validation). The first ACK will be \"intercepted\" by <code>moveServos()</code>, which confirms that the order is valid, and that it will be sent to the robot for execution. The second response is read by the <code>readServerResponse()</code>, and it corresponds to the movement confirmation by the robot MCU.</p> <pre><code>std::cout&lt;&lt;c.moveServos(flag,pV1) &lt;&lt;\" - Servo movemet confirmation\\n\";\nstd::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n    usleep(1500000); // Wait 1.5 seconds\n</code></pre> <p>After every code section, the function <code>usleep()</code> is used to introduce a delay between instructions. While during normal usage this might not be required, in this script it comes in handy to force a minor pause between each block execution - making the individual movements much more obvious and deliberate.</p>"},{"location":"demos/Demo%20Showcase/#code-for-the-demo","title":"Code for the Demo","text":"<p>Below is the main.cpp used for the demo. The complete source files for the client can be found in the TestClient dir of this github repo.</p> main.cpp<pre><code>#include \"Client.h\"\n\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;unistd.h&gt;\n\n\nint main(int argc, char const *argv[]){\n\n    uint32_t flag=0;\n\n    /* Start connection */\n    Client c(ip);\n        usleep(500000);\n\n    /* Select the mcu to control */\n    std::cout&lt;&lt;c.connectToMCU(\"Maroon\") &lt;&lt;\"\\n\";\n        usleep(2500000); // Wait 2.5 seconds\n\n\n    /* Combined movement 1 - Rise hand towards face, tilt head */\n    std::vector&lt;int&gt; pV1;{\n        flag=0;\n        pV1.push_back(0); // rotate palm towards face\n        flag = (flag | (1&lt;&lt;13)); \n        pV1.push_back(0); // flex arm towards face\n        flag = (flag | (1&lt;&lt;15)); \n        pV1.push_back(100); // Rotate arm towards body\n        flag = (flag | (1&lt;&lt;17)); \n        pV1.push_back(179); // Tilt head towards hand\n        flag = (flag | (1&lt;&lt;25)); \n        pV1.push_back(141); // Rotate head towards hand\n        flag = (flag | (1&lt;&lt;26)); \n    }\n    std::cout&lt;&lt;c.moveServos(flag,pV1) &lt;&lt;\" - Servo movemet comprobation\\n\";\n    std::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n        usleep(1500000); // Wait 1.5 seconds\n\n    /* Combined movement 3 - Close hand */\n    std::vector&lt;int&gt; pV3;{\n        flag=0;\n        pV3.push_back(0); // Thumb\n        flag = (flag | (1&lt;&lt;6)); \n        pV3.push_back(0); // Index\n        flag = (flag | (1&lt;&lt;7)); \n        pV3.push_back(0); // Middle\n        flag = (flag | (1&lt;&lt;8)); \n        pV3.push_back(0); // Ring\n        flag = (flag | (1&lt;&lt;9)); \n        pV3.push_back(0); // Little\n        flag = (flag | (1&lt;&lt;10));     }\n    std::cout&lt;&lt;c.moveServos(flag,pV3) &lt;&lt;\" - Servo movemet comprobation\\n\";\n    std::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n        usleep(1500000); // Wait 1.5 seconds\n\n    /* Combined movement 4 - rest hand */\n    std::vector&lt;int&gt; pV4;{\n        flag=0;\n        pV4.push_back(90); // Thumb\n        flag = (flag | (1&lt;&lt;6)); \n        pV4.push_back(90); // Index\n        flag = (flag | (1&lt;&lt;7)); \n        pV4.push_back(90); // Middle\n        flag = (flag | (1&lt;&lt;8)); \n        pV4.push_back(90); // Ring\n        flag = (flag | (1&lt;&lt;9)); \n        pV4.push_back(90); // Little\n        flag = (flag | (1&lt;&lt;10)); \n    }\n    std::cout&lt;&lt;c.moveServos(flag,pV4) &lt;&lt;\" - Servo movemet comprobation\\n\";\n    std::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n        usleep(1500000); // Wait 1.5 seconds\n\n    /* Combined movement 5 - Move arm and head back to \"resting\" position */\n    std::vector&lt;int&gt; pV5;{\n        flag=0;\n        pV5.push_back(90); // rotate palm towards face\n        flag = (flag | (1&lt;&lt;13)); \n        pV5.push_back(60); // flex arm towards face\n        flag = (flag | (1&lt;&lt;15)); \n        pV5.push_back(70); // Rotate arm towards body\n        flag = (flag | (1&lt;&lt;17)); \n        pV5.push_back(126); // Tilt head towards hand\n        flag = (flag | (1&lt;&lt;25)); \n        pV5.push_back(100); // Rotate head towards hand\n        flag = (flag | (1&lt;&lt;26)); \n    }\n    std::cout&lt;&lt;c.moveServos(flag,pV5) &lt;&lt;\" - Servo movemet comprobation\\n\";\n    std::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n        usleep(2500000); // Wait 2.5 seconds\n\n}\n</code></pre>"},{"location":"demos/Platform%20Showcase/","title":"Full Platform Showcase","text":"<p>A demo of the full platform, where the Youbionic Half is controlled via the JavaFX client, performing arm flexion and head rotation.</p> <p></p>"},{"location":"demos/Platform%20Showcase/#platform-components","title":"Platform components","text":"<p>The platform consists of three parts:</p> <ul> <li>Robotic system: The Youbionic half and the power supplies that power it.</li> <li>Server: A computer acting both as server and Wi-Fi Access Point (AP).</li> <li>Client: The laptop is used to run the JavaFX client application and remotely operate the robot. In this demo, it is also used to view the MCU's verbose log, as well as powering the MCU. </li> </ul> Youbionic HalfServerVerbose serial log (MCU) <p></p> <p></p> <p></p>"},{"location":"demos/Platform%20Showcase/#power-requirements","title":"Power requirements","text":"<p>While a proper power consumption study has not been conducted, the servos used by the robotic system do have a fluctuating power draw of 0.72 amps to 0.96 amps at idle. For this reason, the robot is currently hooked up to two DC power supplies, each capable of providing up to 3A@5V. This allows for normal operation of the robot, although the ideal configuration would use a single, high-amp DC power supply at 6 volts.</p> <p>Note that power usage depends on the robotic system's servo configuration, so this observation only applies to those using the same robotic platform and servo combination.</p>"},{"location":"demos/Platform%20Showcase/#wi-fi-connectivity","title":"Wi-Fi Connectivity","text":"<p>The computer acting as server, a Win10 machine, is also used to host the Wi-Fi network that the MCU will connect to. This is achieved by using Windows Mobile hotspot functionality, which allows a computer to share its current internet connection as a hosted Wi-Fi network. Since there's no port forwarding configured, remote operation from outside the networks the server is connected to is impossible.</p> <p>Port Forwarding</p> <p>The server has no login authentication, no encryption and, while it attempts to discard invalid queries, it makes no assurances that all malicious queries will be discarded. As such, it is not recommended to set up a direct or transparent port forward. Doing so will risk your computer and, at that point, you're on your own. </p> <p>If port forwarding is desired, it should be done so through a proxy gateway that enforces some kind of log-in/authentication, traffic filtering or rate-limiting policies, to avoid potential risk to the computer hosting the server.</p>"},{"location":"demos/Platform%20Showcase/#demo-video","title":"Demo Video","text":"<p>Brief demonstration of how the JavaFX application can be used to remotely operate the Youbionic Half. As seen in the video, the delay is almost imperceptible.</p>"},{"location":"demos/UE5%20Module%20Showcase/","title":"UE5 Module Showcase: RemoteClientSystem","text":"<p>This demo intends to show the RemoteClientSystem (RCS) module developed to incorporate this platform's controls into the Unreal Engine 5 ecosystem. </p>"},{"location":"demos/UE5%20Module%20Showcase/#function-suite","title":"Function Suite","text":"<p>The RCS module abstracts away the platform communication protocols into a set of Blueprint-friendly functions that make possible integration of the robotic platform interface into Unreal's scripting system.</p> <p></p>"},{"location":"demos/UE5%20Module%20Showcase/#support-data-structures","title":"Support Data Structures","text":"<p>In order to increase the compatibility and make the usage of the RCS module possible on the Blueprint system, it incorporates the <code>struct FServoInfo</code>, which combines the <code>uint8 servoId</code> and <code>uint8 servoPosition</code> information into a simple, Blueprint compatible data structure.</p> <p></p> <p>RCS also incorporates <code>enum ECLIErrorCode</code>, an enum listing the possible error codes returned by this module's functions. This code can be retrieved using the <code>GetErr()</code> Blueprint function, and filtered against an enum switch, simplifying error handling on UE Blueprints.</p>"},{"location":"demos/UE5%20Module%20Showcase/#rcs-demo","title":"RCS Demo","text":"<p>A brief video showcasing how the UE5 RemoteClientSystem can be used to operate the Youbionic Robot, in this case performing head rotation on each movement order.</p>"},{"location":"demos/UE5%20Module%20Showcase/#demo-blueprint-used","title":"Demo Blueprint used","text":"<p>The Blueprint used for the demo follows a simple logic: check the <code>ServoID=26</code> position, if it's greater than 90, set its value to zero; otherwise, if it's under 90, set it to 179. After this step, the movement order is sent to the server, which in turn makes the Youbionic Half perform the head rotation movement.</p>"}]}