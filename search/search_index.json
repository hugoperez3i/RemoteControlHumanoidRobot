{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Telerobotic Platform:     Remote Control of a Humanoid Robot    <p>blahblah Telerobotic platform, orchestrator model, remote operation of robots with up to 32 servos. </p> <p>educational purpose</p> <p>the platform features a custom lightweight comms protocol focused in functionality and readability</p> <p>It also incorporates a fully developed JavaFX client application, as well as a UE5 module ...</p> <p>This proyect represents the combination of both my Telecommunications Systems Engineering and Biomedical Engineering bachelor's thesis. </p> <p>blahblah platform description</p> <p>blahblah developed client options</p> <p>https://squidfunk.github.io/mkdocs-material/reference/images/#image-alignment-left</p>"},{"location":"Application%20Protocol/Application%20Protocol/","title":"Application Protocol","text":"<p>blahblah protocol</p> <p>blahblah cli - server - mcu</p> <p>blahblah mcu types</p> <p>blahblah no binary zero</p> <p>blahblah proto query formats</p>"},{"location":"Application%20Protocol/Control%20Query/","title":"Control Query","text":"<p>_ACK / NACK</p>"},{"location":"Application%20Protocol/Execution%20Mode/","title":"Execution Mode","text":"<p>eMOD</p>"},{"location":"Application%20Protocol/Identification%20Query/","title":"Identification Query","text":"<p>client_here NodeMCU_here</p>"},{"location":"Application%20Protocol/MCU%20Information/","title":"MCU Information","text":"<p>iMCU</p>"},{"location":"Application%20Protocol/Robot%20Selection/","title":"Robot Selection","text":"<p>sMCU</p>"},{"location":"Application%20Protocol/Server%20Shutdown/","title":"Server Shutdown","text":"<p>sOFF</p>"},{"location":"Application%20Protocol/Servo%20Movement/","title":"Servo Movement","text":"<p>SRVP</p>"},{"location":"Application%20Protocol/Upload%20Information/","title":"Upload Information","text":"<p>UINF</p>"},{"location":"demos/Demo%20Showcase/","title":"Demo Showcase: Scripted actions","text":"<p>A simple showcase of the telerobotic platform working, in which the Youbionic Half performs a scripted movement.</p>"},{"location":"demos/Demo%20Showcase/#showcase-video","title":"Showcase Video","text":""},{"location":"demos/Demo%20Showcase/#demo-walkthrough","title":"Demo walkthrough","text":"<p>This demo intends to show how the platform operates. For this task a simple client is used to control the Youbionic Half robot, and perform a series of scripted movements that resemble the action of looking towards your hand, open and close it, and get back to your original position.</p>"},{"location":"demos/Demo%20Showcase/#server-connection","title":"Server Connection","text":"<p>The first part of the cpp script, available on the next section, creates a client that connects to a given IP at the predefined port <code>57573</code>:</p> <pre><code>/* Start connection */\nClient c(ip);\n    usleep(500000);\n</code></pre>"},{"location":"demos/Demo%20Showcase/#robot-selection","title":"Robot Selection","text":"<p>Then the script selects the robot it wants to control, in this case Maroon - the ID used by the Youbionic Half robot in our setup, using the <code>connectToMCU()</code> function:</p> <pre><code>/* Select the mcu to control */\nstd::cout&lt;&lt;c.connectToMCU(\"Maroon\") &lt;&lt;\"\\n\";\n    usleep(2500000); // Wait 2.5 seconds\n</code></pre>"},{"location":"demos/Demo%20Showcase/#movement-configuration-and-execution","title":"Movement Configuration and Execution","text":"<p>For each movement, the client needs to generate a <code>std::vector&lt;int&gt;</code> in which to store the desired movements. For this client implementation, a <code>uint32_t flag</code> bitmask is also needed. This flag serves as an efficient way of indicating <code>moveServos()</code> the IDs of the servos that we want to move.</p> <p><pre><code>/* Combined movement 1 - Rise hand towards face, tilt head */\nstd::vector&lt;int&gt; pV1;{\n    flag=0;\n    pV1.push_back(0); // rotate palm towards face\n    flag = (flag | (1&lt;&lt;13)); \n    pV1.push_back(0); // flex arm towards face\n    flag = (flag | (1&lt;&lt;15)); \n    pV1.push_back(100); // Rotate arm towards body\n    flag = (flag | (1&lt;&lt;17)); \n    pV1.push_back(179); // Tilt head towards hand\n    flag = (flag | (1&lt;&lt;25)); \n    pV1.push_back(141); // Rotate head towards hand\n    flag = (flag | (1&lt;&lt;26)); \n}\n</code></pre> Lastly, the <code>moveServos()</code> function is used to send the movement order to the server, which will validate it and provide a two-step response (assuming it passes validation). The first ACK will be \"intercepted\" by <code>moveServos()</code>, which confirms that the order is valid, and that it will be sent to the robot for execution. The second response is read by the <code>readServerResponse()</code>, and it corresponds to the movement confirmation by the robot MCU.</p> <pre><code>std::cout&lt;&lt;c.moveServos(flag,pV1) &lt;&lt;\" - Servo movemet confirmation\\n\";\nstd::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n    usleep(1500000); // Wait 1.5 seconds\n</code></pre> <p>After every code section, the function <code>usleep()</code> is used to introduce a delay between instructions. While during normal usage this might not be required, in this script it comes in handy to force a minor pause between each block execution - making the individual movements much more obvious and deliberate.</p>"},{"location":"demos/Demo%20Showcase/#code-for-the-demo","title":"Code for the Demo","text":"<p>Below is the main.cpp used for the demo. The complete source files for the client can be found in the TestClient dir of this github repo.</p> main.cpp<pre><code>#include \"Client.h\"\n\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;unistd.h&gt;\n\n\nint main(int argc, char const *argv[]){\n\n    uint32_t flag=0;\n\n    /* Start connection */\n    Client c(ip);\n        usleep(500000);\n\n    /* Select the mcu to control */\n    std::cout&lt;&lt;c.connectToMCU(\"Maroon\") &lt;&lt;\"\\n\";\n        usleep(2500000); // Wait 2.5 seconds\n\n\n    /* Combined movement 1 - Rise hand towards face, tilt head */\n    std::vector&lt;int&gt; pV1;{\n        flag=0;\n        pV1.push_back(0); // rotate palm towards face\n        flag = (flag | (1&lt;&lt;13)); \n        pV1.push_back(0); // flex arm towards face\n        flag = (flag | (1&lt;&lt;15)); \n        pV1.push_back(100); // Rotate arm towards body\n        flag = (flag | (1&lt;&lt;17)); \n        pV1.push_back(179); // Tilt head towards hand\n        flag = (flag | (1&lt;&lt;25)); \n        pV1.push_back(141); // Rotate head towards hand\n        flag = (flag | (1&lt;&lt;26)); \n    }\n    std::cout&lt;&lt;c.moveServos(flag,pV1) &lt;&lt;\" - Servo movemet comprobation\\n\";\n    std::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n        usleep(1500000); // Wait 1.5 seconds\n\n    /* Combined movement 3 - Close hand */\n    std::vector&lt;int&gt; pV3;{\n        flag=0;\n        pV3.push_back(0); // Thumb\n        flag = (flag | (1&lt;&lt;6)); \n        pV3.push_back(0); // Index\n        flag = (flag | (1&lt;&lt;7)); \n        pV3.push_back(0); // Middle\n        flag = (flag | (1&lt;&lt;8)); \n        pV3.push_back(0); // Ring\n        flag = (flag | (1&lt;&lt;9)); \n        pV3.push_back(0); // Little\n        flag = (flag | (1&lt;&lt;10));     }\n    std::cout&lt;&lt;c.moveServos(flag,pV3) &lt;&lt;\" - Servo movemet comprobation\\n\";\n    std::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n        usleep(1500000); // Wait 1.5 seconds\n\n    /* Combined movement 4 - rest hand */\n    std::vector&lt;int&gt; pV4;{\n        flag=0;\n        pV4.push_back(90); // Thumb\n        flag = (flag | (1&lt;&lt;6)); \n        pV4.push_back(90); // Index\n        flag = (flag | (1&lt;&lt;7)); \n        pV4.push_back(90); // Middle\n        flag = (flag | (1&lt;&lt;8)); \n        pV4.push_back(90); // Ring\n        flag = (flag | (1&lt;&lt;9)); \n        pV4.push_back(90); // Little\n        flag = (flag | (1&lt;&lt;10)); \n    }\n    std::cout&lt;&lt;c.moveServos(flag,pV4) &lt;&lt;\" - Servo movemet comprobation\\n\";\n    std::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n        usleep(1500000); // Wait 1.5 seconds\n\n    /* Combined movement 5 - Move arm and head back to \"resting\" position */\n    std::vector&lt;int&gt; pV5;{\n        flag=0;\n        pV5.push_back(90); // rotate palm towards face\n        flag = (flag | (1&lt;&lt;13)); \n        pV5.push_back(60); // flex arm towards face\n        flag = (flag | (1&lt;&lt;15)); \n        pV5.push_back(70); // Rotate arm towards body\n        flag = (flag | (1&lt;&lt;17)); \n        pV5.push_back(126); // Tilt head towards hand\n        flag = (flag | (1&lt;&lt;25)); \n        pV5.push_back(100); // Rotate head towards hand\n        flag = (flag | (1&lt;&lt;26)); \n    }\n    std::cout&lt;&lt;c.moveServos(flag,pV5) &lt;&lt;\" - Servo movemet comprobation\\n\";\n    std::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n        usleep(2500000); // Wait 2.5 seconds\n\n}\n</code></pre>"},{"location":"demos/Platform%20Showcase/","title":"Full Platform Showcase","text":"<p>A demo of the full platform, where the Youbionic Half is controlled via the JavaFX client, performing arm flexion and head rotation.</p> <p></p>"},{"location":"demos/Platform%20Showcase/#platform-components","title":"Platform components","text":"<p>The platform consists of three parts:</p> <ul> <li>Robotic system: The Youbionic half and the power supplies that power it.</li> <li>Server: A computer acting both as server and Wi-Fi Access Point (AP).</li> <li>Client: The laptop is used to run the JavaFX client application and remotely operate the robot. In this demo, it is also used to view the MCU's verbose log, as well as powering the MCU. </li> </ul> Youbionic HalfServerVerbose serial log (MCU) <p></p> <p></p> <p></p>"},{"location":"demos/Platform%20Showcase/#power-requirements","title":"Power requirements","text":"<p>While a proper power consumption study has not been conducted, the servos used by the robotic system do have a fluctuating power draw of 0.72 amps to 0.96 amps at idle. For this reason, the robot is currently hooked up to two DC power supplies, each capable of providing up to 3A@5V. This allows for normal operation of the robot, although the ideal configuration would use a single, high-amp DC power supply at 6 volts.</p> <p>Note that power usage depends on the robotic system's servo configuration, so this observation only applies to those using the same robotic platform and servo combination.</p>"},{"location":"demos/Platform%20Showcase/#wi-fi-connectivity","title":"Wi-Fi Connectivity","text":"<p>The computer acting as server, a Win10 machine, is also used to host the Wi-Fi network that the MCU will connect to. This is achieved by using Windows Mobile hotspot functionality, which allows a computer to share its current internet connection as a hosted Wi-Fi network. Since there's no port forwarding configured, remote operation from outside the networks the server is connected to is impossible.</p> <p>Port Forwarding</p> <p>The server has no login authentication, no encryption and, while it attempts to discard invalid queries, it makes no assurances that all malicious queries will be discarded. As such, it is not recommended to set up a direct or transparent port forward. Doing so will risk your computer and, at that point, you're on your own. </p> <p>If port forwarding is desired, it should be done so through a proxy gateway that enforces some kind of log-in/authentication, traffic filtering or rate-limiting policies, to avoid potential risk to the computer hosting the server.</p>"},{"location":"demos/Platform%20Showcase/#demo-video","title":"Demo Video","text":"<p>Brief demonstration of how the JavaFX application can be used to remotely operate the Youbionic Half. As seen in the video, the delay is almost imperceptible.</p>"},{"location":"demos/UE5%20Module%20Showcase/","title":"UE5 Module Showcase: RemoteClientSystem","text":"<p>This demo intends to show the RemoteClientSystem (RCS) module developed to incorporate this platform's controls into the Unreal Engine 5 ecosystem. </p>"},{"location":"demos/UE5%20Module%20Showcase/#function-suite","title":"Function Suite","text":"<p>The RCS module abstracts the platform communication protocols into a set of Blueprint-friendly functions that make possible integration of the platform robot interface into unreal's scripting system.</p> <p></p>"},{"location":"demos/UE5%20Module%20Showcase/#support-data-structures","title":"Support Data Structures","text":"<p>In order to increase the compatibility and make the usage of the RCS module on the Blueprint system, it incorporates the <code>struct FServoInfo</code>, which combines the <code>uint8 servoId</code> and <code>uint8 servoPosition</code> information into a simple, Blueprint compatible data structure.</p> <p></p> <p>RCS also incorporates <code>enum ECLIErrorCode</code>, an enum listing the possible error codes returned by this module's functions. This code can be retrieved using the <code>GetErr()</code> Blueprint function, and filtered against an enum switch, simplifying error handling on UE Blueprints.</p>"},{"location":"demos/UE5%20Module%20Showcase/#rcs-demo","title":"RCS Demo","text":"<p>A brief video showcasing how the UE5 RemoteClientSystem can be used to operate the Youbionic Robot, in this case performing head rotation on each movement order.</p>"},{"location":"demos/UE5%20Module%20Showcase/#demo-blueprint-used","title":"Demo Blueprint used","text":"<p>The Blueprint used for the demo follows a simple logic: check the <code>ServoID=26</code> position, if it's greater than 90, set its value to zero; otherwise, if it's under 90, set it to 179. After this step, the movement order is sent to the server, which in turn makes the Youbionic Half perform the head rotation movement.</p>"}]}