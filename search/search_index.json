{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"Telerobotic Platform:         Remote Control of a Humanoid Robot    <p>This project features a telerobotic platform designed for the remote operation of robots. It follows an orchestrator system architecture in which a central server receives commands from remote clients and routes them to the selected robot. </p> <p>Communications between nodes are handled through a custom, lightweight, application-layer protocol focused on clarity and functionality, minimizing overhead while remaining human-readable and easily extendable.</p> <p>The platform includes two client-side implementations. The first one is a fully developed JavaFX application, offering a streamlined graphical interface for direct robot control. The second is a custom Unreal Engine 5 module that integrates into UE5 projects using a blueprint-friendly interface, enabling real-time robotic control from within Unreal-based projects.</p> <p>To sum it up:</p> <ul> <li>Orchestrator-based platform</li> <li>Lightweight, human-readable custom protocol</li> <li>JavaFX GUI Client</li> <li>UE5 Control module with native Blueprint integration</li> </ul> <p>This project merges the work of both my Telecommunications Systems Engineering and Biomedical Engineering bachelor\u2019s theses, combining system-level communications design with applied robotics in a single, complete platform.</p>"},{"location":"Application%20Protocol/Control%20Query/","title":"Control Query","text":"<p>The positive (ACK) and negative (NACK) control queries let the client know whether a requested action was successful or not. In case of failure, NACKs also provide context on what went wrong or where the error occurred.</p> <p>These queries follow the standard protocol structure, using <code>_ACK</code> and <code>NACK</code> as their 4-byte function codes. They include a single byte <code>c</code> as the error code (for positive control queries, <code>c</code> will take always the value <code>uint8_t c=255</code>).</p> Positive (Acknowledge) QueryNegative (No Acknowledge) Query <pre><code>!s-_ACK-c-e!\n</code></pre> <pre><code>!s-NACK-c-e!\n</code></pre> <p>As such, the communication schema in which these queries will be used will look like the one illustrated on the following diagram.</p> Diagram for a positive and negative control query"},{"location":"Application%20Protocol/Execution%20Mode/","title":"Execution Mode","text":"<p>The execution mode query is used by the client to change the execution mode between delayed and real time. It uses the query:</p> <pre><code>!s-eMOD-[EXECUTION_MODE]-e!\n</code></pre> <p>Where the <code>EXECUTION_MODE</code> variable is a single <code>uint8_t</code> binary value that can take two values:</p> <ul> <li><code>_eMOD_Delayed</code> (<code>uint8_t c=100</code>) \u2192 In order to change the execution mode to delayed.</li> <li><code>_eMOD_RealTime</code> (<code>uint8_t c=101</code>) \u2192 In order to change the execution mode to real time.</li> </ul> <p>And the response from the server is either a positive control query, with the same code provided by the client as confirmation, or a negative control query with the error codes:</p> <ul> <li><code>_NACK_InvalidQuery</code> (<code>uint8_t c=255</code>) \u2192 If the query format is invalid: contains null-bytes, invalid header or tail sequences, or the query function code is not recognized.</li> <li><code>_NACK_InvalidParameter</code> (<code>uint8_t c=252</code>) \u2192 If <code>EXECUTION_MODE</code> has a value different than <code>uint8_t c=100</code> (delayed mode) or <code>uint8_t c=101</code> (real time mode).</li> </ul> <p>The possible communication schemas for this query are:</p> Diagram for a successful and failed change of execution mode"},{"location":"Application%20Protocol/Execution%20Mode/#delayed-execution-mode","title":"Delayed Execution Mode","text":"<p>While operating under the delayed execution mode, the servo movement query alters its functionality. Instead of relaying a servo movement query to the mcu, the server will update its internal \"target position\". If the mcu is of the type SmartMCU, the server will send these movements for the mcu to store, but not execute, using the same movement query but replacing the <code>m</code> movement code with a <code>u</code>:</p> <pre><code>-u-[NUMBER_OF_MOVEMENTS]-[SERVO_ID:SERVO_POS]-&lt;...&gt;-[SERVO_ID:SERVO_POS]-!\n</code></pre> <p>The query still follows a similar connection schema as the servo movement query on real time mode:</p> Diagram for a SRVP query on delayed mode <p>This query will not be sent to a mcu of the type DumbMCU. </p> <p>To execute movements while working under delayed execution mode, the client must first configure them by sending one or more servo movement queries. After loading the movements, the client can issue a move servos (delayed mode) query to execute them.</p>"},{"location":"Application%20Protocol/Identification%20Query/","title":"Login Query","text":"<p>The login or identification query informs the server of the type of node initiating the connection, whether it's a client or an mcu.</p> <p>This query poses an exception from the <code>4-byte code</code> structure, though it still follows the overall query structure. Instead of using said code, it relies on two constant sequences <code>Client_here</code> and <code>NodeMCU_here</code>, which represent the client node and mcu nodes respectively.</p> <p>This query has a different behaviour depending on whether it was successful or not. When it succeeds, the server will send no reponse and, on failure, the server will reply with a control query containing an error code identifying the error.  The possible error codes that may be returned by the server are:</p> <ul> <li><code>_NACK_InvalidQuery</code> (<code>uint8_t c=255</code>) \u2192 If the query format is invalid: contains null-bytes, invalid header or tail sequences, or the query does not follow the structure for the client or mcu login queries.</li> </ul>"},{"location":"Application%20Protocol/Identification%20Query/#client-login-query","title":"Client Login Query","text":"<p>The client login query is very straightfoward: The client sends the login query and, assuming there's no unexpected/unknown errors on server-side, the client will be logged to the server successfully. Otherwise, a negative control query will be returned, and the connection will be closed.</p> <p>The login query is a constant sequence of characters with the form: <code>!s-Client_here-e!</code>.</p> Diagram for a successful and failed client login query"},{"location":"Application%20Protocol/Identification%20Query/#mcu-login-query","title":"MCU Login Query","text":"<p>On the other hand, the mcu login query is a little bit more complex. The query will follow a structure similar to the client one, using the constant sequence <code>!s-NodeMCU_here-[info]-e!</code> but with an additional information field, <code>[info]</code>, added to the message. This additional field will contain information about the mcu, such as the unique id or name, used to identify the mcu; the number of servos, which indicates how many servos the mcu has; and either a fixed byte value (<code>uint8_t c=187</code>), if the mcu is of the type DumbMCU; or the current position of each of the mcu servos, if the mcu is of the type SmartMCU.</p> SmartMCU Login QueryDumbMCU Login Query <pre><code>!s-NodeMCU_here-[MCU_UNIQUE_NAME]-[SERVO_COUNT]-[SERVOPOS(0)]-&lt;...&gt;-[SERVOPOS(SERVO_COUNT-1)]-e!\n</code></pre> <ul> <li><code>[MCU_UNIQUE_NAME]</code> \u2192 The unique id used to identify the mcu (<code>char[]</code>).</li> <li><code>[SERVO_COUNT]</code> \u2192 A single <code>uint8_t</code> indicating how many servos the mcu has. Since this number cannot be zero, it does not need any offset applied.</li> <li><code>[SERVOPOS(i)]</code> \u2192 The position of each mcu servo (as a <code>uint8_t</code>), with a dash <code>-</code> between each of them, and ordered by ascending servo ID. Since this value can be zero (0-179 range), by protocol it needs to be offset by +1.</li> </ul> <pre><code>!s-NodeMCU_here-[MCU_UNIQUE_NAME]-[SERVO_COUNT]-[187]-e!\n</code></pre> <ul> <li><code>[MCU_UNIQUE_NAME]</code> \u2192 The unique id used to identify the mcu (<code>char[]</code>).</li> <li><code>[SERVO_COUNT]</code> \u2192 A single <code>uint8_t</code> indicating how many servos the mcu has. Since this number cannot be zero, it does not need any offset applied.</li> <li><code>[187]</code> \u2192 The byte <code>uint8_t b=187</code>. Indicates the server that the mcu is of the type DumbMCU.</li> </ul> Diagram for a successful and failed mcu login query"},{"location":"Application%20Protocol/MCU%20Information/","title":"MCU Information","text":"<p>The MCU Information query, whose code is <code>iMCU</code>, can be used by the client to retrieve the latest mcu data stored at the server.</p> <p>The client \u2192 server query takes the form: <pre><code>!s-iMCU-e!\n</code></pre></p> <p>While the server response, instead of using a standard control query, it mirrors the structure of the additional information from the SmartMCU login query: <pre><code>!s-iMCU-[SERVO_COUNT]-[SERVOPOS(0)]-&lt;...&gt;-[SERVOPOS(SERVO_COUNT-1)]-e!\n</code></pre> Where the variable <code>SERVO_COUNT</code> is a single <code>uint8_t</code> binary value representing the number of servos the selected mcu has, and each <code>SERVOPOS(i)</code> variable is a single <code>uint8_t</code> binary value in the range [1\u2192180], for the current position of the servo with ID=i.</p> <p>In the event an error occurs, the server response will use an error control query, with the following possible error codes:</p> <ul> <li><code>_NACK_InvalidQuery</code> (<code>uint8_t c=255</code>) \u2192 If the query format is invalid: contains null-bytes, invalid header or tail sequences, or the query function code is not recognized.</li> <li><code>_NACK_NoActiveMCU</code> (<code>uint8_t c=254</code>) \u2192 If client has not selected a mcu before issuing the MCU Information command.</li> </ul> <p>The possible communication schemas for this query take the following form:</p> Diagram for a successful and failed mcu information query"},{"location":"Application%20Protocol/Move%20All%20Query/","title":"Move Servos (Delayed Mode) Query","text":"<p>The move servos query on delayed mode uses the message:</p> <pre><code>!s-mALL-e!\n</code></pre> <p>While acting under the delayed execution mode, the client can use this query to execute movements previously loaded through the normal servo movement query. </p> <p>The possible responses for this query by the server are either a relayed generic ACK control query from the mcu after movement execution, or a negative control query with one of the following control codes:</p> <ul> <li><code>_NACK_InvalidQuery</code> (<code>uint8_t c=255</code>) \u2192 If the query format is invalid: contains null-bytes, invalid header or tail sequences, or the query function code is not recognized.</li> <li><code>_NACK_NoActiveMCU</code> (<code>uint8_t c=254</code>) \u2192 If client has not selected a mcu before issuing the movement command.</li> <li><code>_NACK_OnRTMode</code> (<code>uint8_t c=253</code>) \u2192 If the server is not operating on delayed mode.</li> <li><code>_NACK_InvalidParameter</code> (<code>uint8_t c=252</code>) \u2192 If no movements have been previously configured.</li> <li><code>_NACK_NoMCUInfo</code> (<code>uint8_t c=250</code>) \u2192 If the selected mcu is a \"DumbMCU\", and there's no PWM information available in the server database.</li> <li><code>_NACK_MCUOffline</code> (<code>uint8_t c=249</code>) \u2192 If the selected mcu is not currently connected to the server.</li> </ul> <p>The server \u2192 mcu portion of this query behaves and uses the same messages than the normal servo movement query relayed to the mcu, with the exception of the message sent to the SmartMCU, which uses a different query:</p> SmartMCU mALL QueryDumbMCU mALL Query <pre><code>-e-!\n</code></pre> <pre><code>-m-[NUMBER_OF_MOVEMENTS]-[SERVO_ID:PWM_SIGNAL]-&lt;...&gt;-[SERVO_ID:PWM_SIGNAL]-!\n</code></pre> <ul> <li><code>[NUMBER_OF_MOVEMENTS]</code> \u2192 A single <code>uint8_t</code> indicating how many servo movements the query contains. Since it cannot be zero, it's not affected by the offset. </li> <li><code>[SERVO_ID:PWM_SIGNAL]</code> \u2192 The information pair <code>SERVO_ID</code>, the id of the servo the client wants to move; and <code>PWM_SIGNAL</code>, the PWM signal for the given servo ID. These two values are separated by the ASCII character <code>:</code> (<code>uint8_t c=58</code>), and for multiple movements, each information pair <code>SERVO_ID:PWM_SIGNAL</code> is separated by a dash <code>-</code> (<code>uint8_t c=45</code>) from the information pair of the following servo movement. Both <code>SERVO_ID</code> (a single <code>uint8_t</code> value) and <code>PWM_SIGNAL</code> (a <code>uint16_t</code> value) must have the positive +1 offset applied, as they can take value zero.</li> </ul> <p>The communication schema for this query is as follows:</p> Successful Query (SmartMCU)Successful Query (DumbMCU)Failed Query <p> </p> <p> </p> <p> </p>"},{"location":"Application%20Protocol/Protocol%20Definition/","title":"Protocol Definition","text":"<p>The application protocol runs over a persistent socket connection through the TCP/IP stack. Since it relies on TCP for several of its core behaviors, it's recommended, but not required, to disable Nagle's Algorithm by enabling the TCP_NODELAY socket option; and to enable the TCP keepalive with an aggressive setting. By default, the protocol uses port <code>TCP:54817</code>.</p>"},{"location":"Application%20Protocol/Protocol%20Definition/#architecture-components","title":"Architecture Components","text":"<p>The protocol contemplates three types of nodes: client, server and mcu.</p> <ul> <li>Client: Refers to the remote user, which can control a mcu.</li> <li>Server: Refers to the orchestrator service, in charge of query validation and routing client queries to the indicated MCU. </li> <li>MCU: Refers to the remote robotic system, which may be remotely operated by a client.</li> </ul>"},{"location":"Application%20Protocol/Protocol%20Definition/#client-role","title":"Client Role","text":"<p>The client is the only proactive node in the architecture: it sends commands to the server, which either relays them to the mcu or handles them directly before replying with a control response.</p>"},{"location":"Application%20Protocol/Protocol%20Definition/#server-role","title":"Server Role","text":"<p>The server acts as the orchestrator in this architecture. Its functions are routing and validation, interconnecting each client with the mcu it intends to control, and validating the parameters sent by the client before relaying them to the mcu for execution. The server will never send any message to the client or mcu unless prompted by a client query.</p>"},{"location":"Application%20Protocol/Protocol%20Definition/#mcu-role","title":"MCU Role","text":"<p>The mcu is the passive executor node, responsible solely for carrying out orders received from the server. On startup, it sends a login message to the server, then waits for incoming commands, executes them, and replies with an ACK control message.</p>"},{"location":"Application%20Protocol/Protocol%20Definition/#mcu-types","title":"MCU Types","text":"<p>The protocol contemplates two types of MCU robotic systems:</p> <ul> <li>SmartMCU: Refers to a mcu that is capable of generating its own PWM signal values for a given position. This means that a SmartMCU must be able to store locally the PWM calibration values, it also needs to be capable of storing pending movements, and will be required to, on connection, send the current position of each of its servos.</li> <li>DumbMCU: Refers to a mcu that executes movements by reading the PWM signal value directly from the query. This means that a DumbMCU will not receive any information until a movement is expected to be executed, at which point, it will receive a query with the PWM signal value for each servo, instead of a servo position (0\u00ba-179\u00ba). On connection, a DumbMCU is required to send the number of servos it has. </li> </ul>"},{"location":"Application%20Protocol/Protocol%20Definition/#no-binary-zero-convention","title":"No binary zero convention","text":"<p>In order to avoid potential issues with the zero-value bytes (<code>uint8_t b=0</code>), every numerical field that could possibly take the value zero gets offset by +1. This means that fields such as <code>servoId</code> (range 0-31) and <code>servoPosition</code> (range 0-179) will be sent with a +1 positive offset applied: <code>servoId</code> would take the range (1-32) and <code>servoPosition</code> the range (1-180).</p>"},{"location":"Application%20Protocol/Protocol%20Definition/#protocol-query-format","title":"Protocol Query Format","text":"<p>The protocol distinguishes two types of query formats: A client - server format, and a server - mcu format. These two formats were defined to improve the clarity of the protocol, making it obvious which part of the communication chain a given query belongs to. However, the login query poses an exception to these formats, where client and mcu have a unique query style, also different from the other query formats.</p> <p>The protocol query uses plain, raw binary, with no codification or encryption. All format and structure characters are standard ASCII.</p>"},{"location":"Application%20Protocol/Protocol%20Definition/#client-server-query-format","title":"Client - Server Query Format","text":"<p>The message follows a set structure: it always starts with a constant header, <code>!s-</code>, followed by a 4-byte function selector code <code>CODE</code>, and is terminated by a constant tail <code>-e!</code>. This structure can accommodate additional information, for those functions that require it: the information will be added behind the four-byte function selector code (<code>CODE</code>), separated with an additional slash <code>-</code>.</p> No additional informationContaining additional information <pre><code>!s-CODE-e!\n</code></pre> <pre><code>!s-CODE-[ADDITIONAL_INFORMATION]-e!  \n</code></pre> <p>This means that the minimum query length will be <code>11</code> bytes (3 from the header <code>!s-</code>, +4 from the selection code <code>CODE</code>, and +3 from the tail sequence <code>-e!</code>). Any query with less than <code>11 bytes</code> can be safely deleted, as it would mean that some kind of error happened during query formation.</p>"},{"location":"Application%20Protocol/Protocol%20Definition/#server-mcu-query-format","title":"Server - MCU Query Format","text":"<p>Similarly to the client - server query, the server - mcu query also uses an structured format with header and tail. However, in this second format, the header is reduced to a single <code>-</code>, while the tail sequence takes the form <code>-!</code>. The 4-byte function selector code becomes a single-byte code <code>c</code>, and the additional information, when needed, is added in the exact same format as the client - server format: behind the single-byte code <code>c</code>, and separated with a dash character <code>-</code>.</p> No additional informationContaining additional information <pre><code>-c-!\n</code></pre> <pre><code>-c-[ADDITIONAL_INFORMATION]-!\n</code></pre>"},{"location":"Application%20Protocol/Protocol%20Definition/#pwm-signal-encoding","title":"PWM Signal Encoding","text":"<p>Some queries, such as Upload Calibration Data, Servo Movement, and Servo Movement (Delayed Mode), rely on a custom <code>uint16_t</code> encoding to transmit the PWM signal. This codification is explained in the documentation for each relevant query. It's also available on the following area:</p> PWM Signal codification <p>Since the PWM signal can take various bit resolution levels, usually ranging from 8-bit to 16-bit, with &gt;16bit being niche or application-specific territory, the procotol allocates 2 bytes (up to 15-bit pwm resolution) for PWM signals on SRVP queries. </p> <p>This means that in order to follow the protocol no-zero convention, each individual byte needs to incorporate this offset. This is required because, for values of <code>PWM_SIGNAL&lt;255</code>, the upper-byte will always be zero, and for the specific value <code>PWM_SIGNAL=256</code>, the lower-byte will be zero. </p> <p>How is offset applied</p> <p>The offset is introduced by fixing the most significant bit of the <code>uint16_t PWM_SIGNAL</code> to <code>1</code>, and then adding 1 to the normal PWM signal value. This results in a 15-bit signal with one fewer representable PWM value, a range of [0 \u2192 32766]. On PWM servos that use the full 15-bit resolution over a 180\u00ba linear range, this results in a precision loss of approximately 5.493 millidegrees reduction in total range, and 0.1676 microdegrees decrease in angular resolution per step, which is effectively negligible for most use-cases.</p> <p>To introduce this offset, the formula <code>PWM_SIGNAL = pwm + (1+(0b1&lt;&lt;15))</code> is used; and the formula <code>pwm = PWM_SIGNAL - (1+(0b1&lt;&lt;15))</code> is used on the receiving end to undo the offset applied.</p> Endianness <p>To avoid the endianness problem, the protocol introduces a normalized implementation through which <code>uint16_t</code> values are split into two <code>uint8_t</code> values in a set order (the first byte will be the upper-byte, followed by the lower-byte). The visual representation of this transformation would be:</p> <p> </p> <p>And the functions used for this are:</p> divideIntoBytes()<pre><code>std::string QueryGenerator::divideIntoBytes(uint16_t u){\n    std::string hl = \"\";\n    hl+=(uint8_t)(u&gt;&gt;8);\n    hl+=(uint8_t)(u&amp;0x00ff);\n    return hl;\n}\n</code></pre> restore16int()<pre><code>inline uint16_t QueryGenerator::restore16int(uint8_t c0,uint8_t c1){return (c0&lt;&lt;8)+c1;}\n</code></pre>"},{"location":"Application%20Protocol/Protocol%20Definition/#protocol-queries-overview","title":"Protocol Queries Overview","text":"<p>The following table lists all queries defined by the protocol, as well as a brief description and links to each of their documentation pages:</p> Query Additional Information Description Documentation <code>!s-_ACK-[c]-e!</code> Success code Sent by server or MCU to acknowledge successful execution Link <code>!s-NACK-[c]-e!</code> Error code Sent by server or MCU to indicate an error Link <code>!s-Client_here-e!</code> None Sent by client to identify and initiate login Link <code>!s-NodeMCU_here-[info]-e!</code> Unique ID + Servo positions and count Sent by MCU to register itself with the server Link <code>!s-sMCU-[info]-e!</code> MCU Unique ID Sent by client to select which MCU to control Link <code>!s-SRVP-[info]-e!</code> Number of movements + Information for each servo movement Sent by client to execute servo movement on selected MCU Link <code>-m-[info]-!</code> Number of movements + Information for each servo movement Sent by server to MCU to execute servo movements Link <code>-u-[info]-!</code> Number of movements + Information for each servo movement Sent by server to MCU to store delayed servo movements Link <code>!s-iMCU-[info]-e!</code> On server response: Servo positions and count Sent by client to request current MCU servo positions Link <code>!s-eMOD-[info]-e!</code> The execution mode Sent by client to set MCU execution mode (real-time or delayed) Link <code>!s-mALL-e!</code> None Sent by client to trigger execution of stored servo movements Link <code>-e-!</code> None Sent by server to instruct MCU to execute stored movements Link <code>!s-uINF-[info]-e!</code> Number of servos + calibration data for each servo Sent by client to upload calibration data to MCU Link <code>!s-sOFF-e!</code> None Sent by client to shut down the server remotely Link"},{"location":"Application%20Protocol/Robot%20Selection/","title":"MCU Selection","text":"<p>The robot selection query (switch MCU, using the 4-byte code <code>sMCU</code>) is used by the client to inform the server which mcu it wants to control. For this, the query uses a single additional information field, <code>[MCU_UNIQUE_NAME]</code>, containing the unique identifier the mcu used at server login. The query structure will be:</p> <pre><code>!s-sMCU-[MCU_UNIQUE_NAME]-e!\n</code></pre> <p>On a successful request, the server will return a positive control query. While if there's an error, the server will return one of the following error codes:</p> <ul> <li><code>_NACK_InvalidQuery</code> (<code>uint8_t c=255</code>) \u2192 If the query format is invalid: contains null-bytes, invalid header or tail sequences, or the query function code is not recognized.</li> <li><code>_NACK_NoActiveMCU</code> (<code>uint8_t c=254</code>) \u2192 If the variable <code>[MCU_UNIQUE_NAME]</code> is empty (<code>!s-sMCU--e!</code>), or if the given <code>[MCU_UNIQUE_NAME]</code> identifier does not exist on the server database.</li> </ul> <p>As such, the communication schema for this query type will look like the one illustrated on the following diagram.</p> Diagram for a successful and failed mcu selection query"},{"location":"Application%20Protocol/Server%20Shutdown/","title":"Server Shutdown","text":"<p>The server shutdown message's only purpose is to remotely disconnect and shut down the server. It uses the fixed format:</p> <pre><code>!s-sOFF-e!\n</code></pre> <p>If successful, the server replies with an ACK control query. If it fails, mostly due to invalid format or a similar issue, it will return with a NACK: <code>_NACK_InvalidQuery</code> (<code>uint8_t c=255</code>). As such, the communication schema for this query will look like the one illustrated on the following diagram.</p>"},{"location":"Application%20Protocol/Servo%20Movement/","title":"Servo Movement","text":""},{"location":"Application%20Protocol/Servo%20Movement/#client-server-servo-movement-query-format","title":"Client \u2192 Server Servo Movement Query Format","text":"<p>The servo movement query (which uses the 4-byte code <code>SRVP</code>) is used by the client to issue movement commands for the selected mcu. The query has the structure:</p> SmartMCU SRVP QueryDumbMCU SRVP Query <pre><code>!s-SRVP-[NUMBER_OF_MOVEMENTS]-[SERVO_ID:SERVO_POS]-&lt;...&gt;-[SERVO_ID:SERVO_POS]-e!\n</code></pre> <ul> <li><code>[NUMBER_OF_MOVEMENTS]</code> \u2192 A single <code>uint8_t</code> indicating how many servo movements the query contains. Since it cannot be zero, it's not affected by the offset. </li> <li><code>[SERVO_ID:SERVO_POS]</code> \u2192 The information pair <code>SERVO_ID</code>, the id of the servo the client wants to move; and <code>SERVO_POS</code>, the position the servo has to take. These two values are separated by the ASCII character <code>:</code> (<code>uint8_t c=58</code>), and for multiple movements, each information pair <code>SERVO_ID:SERVO_POS</code> is separated by a dash <code>-</code> (<code>uint8_t c=45</code>) from the information pair of the following servo movement. Both <code>SERVO_ID</code> and <code>SERVO_POS</code> are single <code>uint8_t</code> values, and must have the positive +1 offset applied, as they can take value zero.</li> </ul> <pre><code>!s-SRVP-[NUMBER_OF_MOVEMENTS]-[SERVO_ID:PWM_SIGNAL]-&lt;...&gt;-[SERVO_ID:PWM_SIGNAL]-e!\n</code></pre> <ul> <li><code>[NUMBER_OF_MOVEMENTS]</code> \u2192 A single <code>uint8_t</code> indicating how many servo movements the query contains. Since it cannot be zero, it's not affected by the offset. </li> <li><code>[SERVO_ID:PWM_SIGNAL]</code> \u2192 The information pair <code>SERVO_ID</code>, the id of the servo the client wants to move; and <code>PWM_SIGNAL</code>, the PWM signal for the given servo ID. These two values are separated by the ASCII character <code>:</code> (<code>uint8_t c=58</code>), and for multiple movements, each information pair <code>SERVO_ID:PWM_SIGNAL</code> is separated by a dash <code>-</code> (<code>uint8_t c=45</code>) from the information pair of the following servo movement. Both <code>SERVO_ID</code> (a single <code>uint8_t</code> value) and <code>PWM_SIGNAL</code> (a <code>uint16_t</code> value) must have the positive +1 offset applied, as they can take value zero.</li> </ul> <p>Due to the server function of query parameter validation, the response for this query can take two forms: </p> <p>If during validation, the server rejects a query for any reason, it will return a single NACK control query to the client, ending the SRVP process. The defined possible NACK codes for this first reponse are:</p> <ul> <li><code>_NACK_InvalidQuery</code> (<code>uint8_t c=255</code>) \u2192 If the query format is invalid: contains null-bytes, invalid header or tail sequences, or the query function code is not recognized.</li> <li><code>_NACK_NoActiveMCU</code> (<code>uint8_t c=254</code>) \u2192 If client has not selected a mcu before issuing the movement command.</li> <li><code>_NACK_InvalidParameter</code> (<code>uint8_t c=252</code>) \u2192 If the query parameters are out of range: a servo id exceeds the selected mcu servo count, or a servo position out of the range [1\u2192180].</li> <li><code>_NACK_ServoCountMissmatch</code> (<code>uint8_t c=251</code>) \u2192 If the movement order tries to move more servos than the selected mcu has.</li> <li><code>_NACK_NoMCUInfo</code> (<code>uint8_t c=250</code>) \u2192 If the selected mcu is a \"DumbMCU\", and there's no PWM information available in the server database.</li> <li><code>_NACK_MCUOffline</code> (<code>uint8_t c=249</code>) \u2192 If the selected mcu is not currently connected to the server.</li> </ul> <p>On the other hand, if the server validates the parameters, it will return a first ACK control query to the client and forward the SRVP query to the target mcu. Once the mcu performs the movement, it will reply with a control query to the server, which is then be relayed back to the client as a second control response. For this second control query, the defined possible NACK codes are:</p> <ul> <li><code>_NACK_InvalidQuery</code> (<code>uint8_t c=255</code>) \u2192 Should never happen: If the query format is invalid: contains null-bytes, invalid header or tail sequences, or the query function code is not recognized.</li> <li><code>_NACK_NoActiveMCU</code> (<code>uint8_t c=254</code>) \u2192 If client has not selected a mcu before issuing the movement command. Would happen if another client selects the same mcu as the current client.</li> <li><code>_NACK_MCUOffline</code> (<code>uint8_t c=249</code>) \u2192 If the selected mcu is not currently connected to the server. Would happen if the mcu disconnects between the client query validation and the server message to the mcu.</li> <li><code>_NACK_ErrorContactingMCU</code> (<code>uint8_t c=248</code>) \u2192 If the selected mcu is not currently connected to the server.</li> </ul> <p>During the second control response, both <code>_NACK_NoActiveMCU</code> and <code>_NACK_MCUOffline</code> represent time-of-check time-of-use conditions catched by the server during query dispatch.</p>"},{"location":"Application%20Protocol/Servo%20Movement/#server-mcu-servo-movement-query-format","title":"Server \u2192 MCU Servo Movement Query Format","text":"<p>The servo movement query sent by the client must be translated from the client \u2192 server into the server \u2192 mcu format before forwarding it to the mcu, which makes the query take the form:</p> SmartMCU SRVP QueryDumbMCU SRVP Query <pre><code>-m-[NUMBER_OF_MOVEMENTS]-[SERVO_ID:SERVO_POS]-&lt;...&gt;-[SERVO_ID:SERVO_POS]-!\n</code></pre> <pre><code>-m-[NUMBER_OF_MOVEMENTS]-[SERVO_ID:PWM_SIGNAL]-&lt;...&gt;-[SERVO_ID:PWM_SIGNAL]-!\n</code></pre> <p>Where the query parameters <code>[NUMBER_OF_MOVEMENTS]</code>, <code>[SERVO_ID:SERVO_POS]</code> and <code>[SERVO_ID:PWM_SIGNAL]</code> remain unchanged and adhere to the same rules as the client \u2192 server format.</p>"},{"location":"Application%20Protocol/Servo%20Movement/#pwm-signal-codification","title":"PWM Signal codification","text":"<p>Since the PWM signal can take various bit resolution levels, usually ranging from 8-bit to 16-bit, with &gt;16bit being niche or application-specific territory, the procotol allocates 2 bytes (up to 15-bit pwm resolution) for PWM signals on SRVP queries. </p> <p>This means that in order to follow the protocol no-zero convention, each individual byte needs to incorporate this offset. This is required because, for values of <code>PWM_SIGNAL&lt;255</code>, the upper-byte will always be zero, and for the specific value <code>PWM_SIGNAL=256</code>, the lower-byte will be zero. </p> <p>How is offset applied</p> <p>The offset is introduced by fixing the most significant bit of the <code>uint16_t PWM_SIGNAL</code> to <code>1</code>, and then adding 1 to the normal PWM signal value. This results in a 15-bit signal with one fewer representable PWM value, a range of [0 \u2192 32766]. On PWM servos that use the full 15-bit resolution over a 180\u00ba linear range, this results in a precision loss of approximately 5.493 millidegrees reduction in total range, and 0.1676 microdegrees decrease in angular resolution per step, which is effectively negligible for most use-cases.</p> <p>To introduce this offset, the formula <code>PWM_SIGNAL = pwm + (1+(0b1&lt;&lt;15))</code> is used; and the formula <code>pwm = PWM_SIGNAL - (1+(0b1&lt;&lt;15))</code> is used on the receiving end to undo the offset applied.</p> Endianness <p>To avoid the endianness problem, the protocol introduces a normalized implementation through which <code>uint16_t</code> values are split into two <code>uint8_t</code> values in a set order (the first byte will be the upper-byte, followed by the lower-byte). The visual representation of this transformation would be:</p> <p> </p> <p>And the functions used for this are:</p> divideIntoBytes()<pre><code>std::string QueryGenerator::divideIntoBytes(uint16_t u){\n    std::string hl = \"\";\n    hl+=(uint8_t)(u&gt;&gt;8);\n    hl+=(uint8_t)(u&amp;0x00ff);\n    return hl;\n}\n</code></pre> restore16int()<pre><code>inline uint16_t QueryGenerator::restore16int(uint8_t c0,uint8_t c1){return (c0&lt;&lt;8)+c1;}\n</code></pre>"},{"location":"Application%20Protocol/Servo%20Movement/#examples-srvp-communication-overview","title":"Examples: SRVP Communication Overview","text":"<p>The servo movement query takes on a different communication path depending on whether the server validation passes or fails. The possible schemas are:</p> Successful SRVP QueryRejected SRVP QueryRejected by MCU <p>For instance, the movement query <code>!s-SRVP-2-9:13-7:18-e!</code> would translate to \"Perform 2 servo movements: move servo ID 8 to position 12, and servo ID 6 to position 17\". Assuming the parameters are valid, and the selected mcu is online, the query validation would succeed, returning the first ACK to the client while forwarding the SRVP query to the mcu. Once the mcu completes the movements, it will reply with a positive control query, which will be relayed back to the client as a second ACK.</p> <p> </p> <p>On the other hand, if the user sends the query <code>!s-SRVP-1-3:187-e!</code> the movement order (move servo id=2, to position 186) would be invalid, as the servo position is out-of-range. In this case, the server validation would catch it, returning a negative control code (<code>_NACK_InvalidParameter</code>) to the client, and ending the SRVP query \"process\". </p> <p> </p> <p>The final option is that, once validated by the server, the mcu deems the movement order invalid. This would lead to a positive first control response, followed by a negative control query. In this case, similar to the SRVP rejection by server, no movement is performed.</p> <p> </p>"},{"location":"Application%20Protocol/Upload%20Information/","title":"Upload MCU Information Query","text":"<p>The upload mcu information query can be used by the client to upload the mcu PWM information. This information is required in order to operate a \"DumbMCU\". The query uses the format:</p> <pre><code>!s-uINF-[SERVO_COUNT]-[PWM_MIN(0):PWM_MAX(0)]-&lt;...&gt;-[PWM_MIN(SERVO_COUNT-1):PWM_MAX(SERVO_COUNT-1)]-e!\n</code></pre> <ul> <li><code>[SERVO_COUNT]</code> \u2192 A single <code>uint8_t</code> indicating how many servos the mcu has. Since this number cannot be zero, it does not need any offset applied.</li> <li><code>[PWM_MIN:PWM_MAX]</code> \u2192 The information pair <code>PWM_MIN</code>, the minimum PWM signal position; and <code>PWM_MAX</code>, the maximum PWM signal for the given servo; which represent the calibration information for a given servo. These two PWM values are separated by the ASCII character <code>:</code> (<code>uint8_t c=58</code>), and for multiple movements, each information pair <code>PWM_MIN(i):PWM_MAX(i)</code> is separated by a dash <code>-</code> (<code>uint8_t c=45</code>) from the information pair of the following servo calibration. Both of the <code>PWM_SIGNAL</code> (<code>uint16_t</code> values) must have the positive +1 offset applied, as they can take value zero.</li> </ul> <p>The possible responses for this query by the server are either a generic ACK control query, or a negative control query with one of the following control codes:</p> <ul> <li><code>_NACK_InvalidQuery</code> (<code>uint8_t c=255</code>) \u2192 If the query format is invalid: contains null-bytes, invalid header or tail sequences, or the query function code is not recognized.</li> <li><code>_NACK_NoActiveMCU</code> (<code>uint8_t c=254</code>) \u2192 If client has not selected a mcu before issuing the command.</li> <li><code>_NACK_InvalidParameter</code> (<code>uint8_t c=252</code>) \u2192 If the query parameters are out of range: a servo id exceeds the selected mcu servo count, or a PWM signal value out of the range [0\u219232766].</li> <li><code>_NACK_ServoCountMissmatch</code> (<code>uint8_t c=251</code>) \u2192 If the user tries to update information for a different number of servos than the selected mcu has.</li> <li><code>_NACK_ErrorLoadingMINMAX</code> (<code>uint8_t c=247</code>) \u2192 If the PWM information could not be loaded into the server database.</li> </ul>"},{"location":"Application%20Protocol/Upload%20Information/#pwm-signal-codification","title":"PWM Signal codification","text":"<p>Since the PWM signal can take various bit resolution levels, usually ranging from 8-bit to 16-bit, with &gt;16bit being niche or application-specific territory, the procotol allocates 2 bytes (up to 15-bit pwm resolution) for PWM signals on SRVP queries. </p> <p>This means that in order to follow the protocol no-zero convention, each individual byte needs to incorporate this offset. This is required because, for values of <code>PWM_SIGNAL&lt;255</code>, the upper-byte will always be zero, and for the specific value <code>PWM_SIGNAL=256</code>, the lower-byte will be zero. </p> <p>How is offset applied</p> <p>The offset is introduced by fixing the most significant bit of the <code>uint16_t PWM_SIGNAL</code> to <code>1</code>, and then adding 1 to the normal PWM signal value. This results in a 15-bit signal with one fewer representable PWM value, a range of [0 \u2192 32766]. On PWM servos that use the full 15-bit resolution over a 180\u00ba linear range, this results in a precision loss of approximately 5.493 millidegrees reduction in total range, and 0.1676 microdegrees decrease in angular resolution per step, which is effectively negligible for most use-cases.</p> <p>To introduce this offset, the formula <code>PWM_SIGNAL = pwm + (1+(0b1&lt;&lt;15))</code> is used; and the formula <code>pwm = PWM_SIGNAL - (1+(0b1&lt;&lt;15))</code> is used on the receiving end to undo the offset applied.</p> Endianness <p>To avoid the endianness problem, the protocol introduces a normalized implementation through which <code>uint16_t</code> values are split into two <code>uint8_t</code> values in a set order (the first byte will be the upper-byte, followed by the lower-byte). The visual representation of this transformation would be:</p> <p> </p> <p>And the functions used for this are:</p> divideIntoBytes()<pre><code>std::string QueryGenerator::divideIntoBytes(uint16_t u){\n    std::string hl = \"\";\n    hl+=(uint8_t)(u&gt;&gt;8);\n    hl+=(uint8_t)(u&amp;0x00ff);\n    return hl;\n}\n</code></pre> restore16int()<pre><code>inline uint16_t QueryGenerator::restore16int(uint8_t c0,uint8_t c1){return (c0&lt;&lt;8)+c1;}\n</code></pre>"},{"location":"Application%20Protocol/Upload%20Information/#uinf-communication-overview","title":"uINF Communication Overview","text":""},{"location":"demos/Demo%20Showcase/","title":"Demo Showcase: Scripted actions","text":"<p>A simple showcase of the telerobotic platform working, in which the Youbionic Half performs a scripted movement.</p>"},{"location":"demos/Demo%20Showcase/#showcase-video","title":"Showcase Video","text":""},{"location":"demos/Demo%20Showcase/#demo-walkthrough","title":"Demo walkthrough","text":"<p>This demo intends to show how the platform operates. For this task, a simple client is used to control the Youbionic Half robot, and perform a series of scripted movements that resemble the action of looking towards your hand, opening and closing it, and then get back to your original position.</p>"},{"location":"demos/Demo%20Showcase/#server-connection","title":"Server Connection","text":"<p>The first part of the cpp script, available on the next section, creates a client that connects to a given IP at the predefined port <code>57573</code>:</p> <pre><code>/* Start connection */\nClient c(ip);\n    usleep(500000);\n</code></pre>"},{"location":"demos/Demo%20Showcase/#robot-selection","title":"Robot Selection","text":"<p>Then the script selects the robot it wants to control, in this case Maroon - the ID used by the Youbionic Half robot in our setup, using the <code>connectToMCU()</code> function:</p> <pre><code>/* Select the mcu to control */\nstd::cout&lt;&lt;c.connectToMCU(\"Maroon\") &lt;&lt;\"\\n\";\n    usleep(2500000); // Wait 2.5 seconds\n</code></pre>"},{"location":"demos/Demo%20Showcase/#movement-configuration-and-execution","title":"Movement Configuration and Execution","text":"<p>For each movement, the client needs to generate a <code>std::vector&lt;int&gt;</code> in which to store the desired movements. For this client implementation, a <code>uint32_t flag</code> bitmask is also needed. This flag serves as an efficient way of indicating <code>moveServos()</code> the IDs of the servos that we want to move.</p> <p><pre><code>/* Combined movement 1 - Rise hand towards face, tilt head */\nstd::vector&lt;int&gt; pV1;{\n    flag=0;\n    pV1.push_back(0); // rotate palm towards face\n    flag = (flag | (1&lt;&lt;13)); \n    pV1.push_back(0); // flex arm towards face\n    flag = (flag | (1&lt;&lt;15)); \n    pV1.push_back(100); // Rotate arm towards body\n    flag = (flag | (1&lt;&lt;17)); \n    pV1.push_back(179); // Tilt head towards hand\n    flag = (flag | (1&lt;&lt;25)); \n    pV1.push_back(141); // Rotate head towards hand\n    flag = (flag | (1&lt;&lt;26)); \n}\n</code></pre> Lastly, the <code>moveServos()</code> function is used to send the movement order to the server, which will validate it and provide a two-step response (assuming it passes validation). The first ACK will be \"intercepted\" by <code>moveServos()</code>, which confirms that the order is valid, and that it will be sent to the robot for execution. The second response is read by the <code>readServerResponse()</code>, and it corresponds to the movement confirmation by the robot MCU.</p> <pre><code>std::cout&lt;&lt;c.moveServos(flag,pV1) &lt;&lt;\" - Servo movemet confirmation\\n\";\nstd::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n    usleep(1500000); // Wait 1.5 seconds\n</code></pre> <p>After every code section, the function <code>usleep()</code> is used to introduce a delay between instructions. While during normal usage this might not be required, in this script it comes in handy to force a minor pause between each block execution - making the individual movements much more obvious and deliberate.</p>"},{"location":"demos/Demo%20Showcase/#code-for-the-demo","title":"Code for the Demo","text":"<p>Below is the main.cpp used for the demo. The complete source files for the client can be found in the TestClient dir of this github repo.</p> main.cpp<pre><code>#include \"Client.h\"\n\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;unistd.h&gt;\n\n\nint main(int argc, char const *argv[]){\n\n    uint32_t flag=0;\n\n    /* Start connection */\n    Client c(ip);\n        usleep(500000);\n\n    /* Select the mcu to control */\n    std::cout&lt;&lt;c.connectToMCU(\"Maroon\") &lt;&lt;\"\\n\";\n        usleep(2500000); // Wait 2.5 seconds\n\n\n    /* Combined movement 1 - Rise hand towards face, tilt head */\n    std::vector&lt;int&gt; pV1;{\n        flag=0;\n        pV1.push_back(0); // rotate palm towards face\n        flag = (flag | (1&lt;&lt;13)); \n        pV1.push_back(0); // flex arm towards face\n        flag = (flag | (1&lt;&lt;15)); \n        pV1.push_back(100); // Rotate arm towards body\n        flag = (flag | (1&lt;&lt;17)); \n        pV1.push_back(179); // Tilt head towards hand\n        flag = (flag | (1&lt;&lt;25)); \n        pV1.push_back(141); // Rotate head towards hand\n        flag = (flag | (1&lt;&lt;26)); \n    }\n    std::cout&lt;&lt;c.moveServos(flag,pV1) &lt;&lt;\" - Servo movemet comprobation\\n\";\n    std::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n        usleep(1500000); // Wait 1.5 seconds\n\n    /* Combined movement 3 - Close hand */\n    std::vector&lt;int&gt; pV3;{\n        flag=0;\n        pV3.push_back(0); // Thumb\n        flag = (flag | (1&lt;&lt;6)); \n        pV3.push_back(0); // Index\n        flag = (flag | (1&lt;&lt;7)); \n        pV3.push_back(0); // Middle\n        flag = (flag | (1&lt;&lt;8)); \n        pV3.push_back(0); // Ring\n        flag = (flag | (1&lt;&lt;9)); \n        pV3.push_back(0); // Little\n        flag = (flag | (1&lt;&lt;10));     }\n    std::cout&lt;&lt;c.moveServos(flag,pV3) &lt;&lt;\" - Servo movemet comprobation\\n\";\n    std::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n        usleep(1500000); // Wait 1.5 seconds\n\n    /* Combined movement 4 - rest hand */\n    std::vector&lt;int&gt; pV4;{\n        flag=0;\n        pV4.push_back(90); // Thumb\n        flag = (flag | (1&lt;&lt;6)); \n        pV4.push_back(90); // Index\n        flag = (flag | (1&lt;&lt;7)); \n        pV4.push_back(90); // Middle\n        flag = (flag | (1&lt;&lt;8)); \n        pV4.push_back(90); // Ring\n        flag = (flag | (1&lt;&lt;9)); \n        pV4.push_back(90); // Little\n        flag = (flag | (1&lt;&lt;10)); \n    }\n    std::cout&lt;&lt;c.moveServos(flag,pV4) &lt;&lt;\" - Servo movemet comprobation\\n\";\n    std::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n        usleep(1500000); // Wait 1.5 seconds\n\n    /* Combined movement 5 - Move arm and head back to \"resting\" position */\n    std::vector&lt;int&gt; pV5;{\n        flag=0;\n        pV5.push_back(90); // rotate palm towards face\n        flag = (flag | (1&lt;&lt;13)); \n        pV5.push_back(60); // flex arm towards face\n        flag = (flag | (1&lt;&lt;15)); \n        pV5.push_back(70); // Rotate arm towards body\n        flag = (flag | (1&lt;&lt;17)); \n        pV5.push_back(126); // Tilt head towards hand\n        flag = (flag | (1&lt;&lt;25)); \n        pV5.push_back(100); // Rotate head towards hand\n        flag = (flag | (1&lt;&lt;26)); \n    }\n    std::cout&lt;&lt;c.moveServos(flag,pV5) &lt;&lt;\" - Servo movemet comprobation\\n\";\n    std::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n        usleep(2500000); // Wait 2.5 seconds\n\n}\n</code></pre>"},{"location":"demos/Platform%20Showcase/","title":"Full Platform Showcase","text":"<p>A demo of the full platform, where the Youbionic Half is controlled via the JavaFX client, performing arm flexion and head rotation.</p> <p></p>"},{"location":"demos/Platform%20Showcase/#platform-components","title":"Platform components","text":"<p>The platform consists of three parts:</p> <ul> <li>Robotic system: The Youbionic half and the power supplies that power it.</li> <li>Server: A computer acting both as server and Wi-Fi Access Point (AP).</li> <li>Client: The laptop is used to run the JavaFX client application and remotely operate the robot. In this demo, it is also used to view the MCU's verbose log, as well as powering the MCU. </li> </ul> Youbionic HalfServerVerbose serial log (MCU) <p></p> <p></p> <p></p>"},{"location":"demos/Platform%20Showcase/#power-requirements","title":"Power requirements","text":"<p>While a proper power consumption study has not been conducted, the servos used by the robotic system do have a fluctuating power draw of 0.72 amps to 0.96 amps at idle. For this reason, the robot is currently hooked up to two DC power supplies, each capable of providing up to 3A@5V. This allows for normal operation of the robot, although the ideal configuration would use a single, high-amp DC power supply at 6 volts.</p> <p>Note that power usage depends on the robotic system's servo configuration, so this observation only applies to those using the same robotic platform and servo combination.</p>"},{"location":"demos/Platform%20Showcase/#wi-fi-connectivity","title":"Wi-Fi Connectivity","text":"<p>The computer acting as server, a Win10 machine, is also used to host the Wi-Fi network that the MCU will connect to. This is achieved by using Windows Mobile hotspot functionality, which allows a computer to share its current internet connection as a hosted Wi-Fi network. Since there's no port forwarding configured, remote operation from outside the networks the server is connected to is impossible.</p> <p>Port Forwarding</p> <p>The server has no login authentication, no encryption and, while it attempts to discard invalid queries, it makes no assurances that all malicious queries will be discarded. As such, it is not recommended to set up a direct or transparent port forward. Doing so will risk your computer and, at that point, you're on your own. </p> <p>If port forwarding is desired, it should be done so through a proxy gateway that enforces some kind of log-in/authentication, traffic filtering or rate-limiting policies, to avoid potential risk to the computer hosting the server.</p>"},{"location":"demos/Platform%20Showcase/#demo-video","title":"Demo Video","text":"<p>Brief demonstration of how the JavaFX application can be used to remotely operate the Youbionic Half. As seen in the video, the delay is almost imperceptible.</p>"},{"location":"demos/UE5%20Module%20Showcase/","title":"UE5 Module Showcase: RemoteClientSystem","text":"<p>This demo intends to show the RemoteClientSystem (RCS) module developed to incorporate this platform's controls into the Unreal Engine 5 ecosystem. </p>"},{"location":"demos/UE5%20Module%20Showcase/#function-suite","title":"Function Suite","text":"<p>The RCS module abstracts away the platform communication protocols into a set of Blueprint-friendly functions that make possible integration of the robotic platform interface into Unreal's scripting system.</p> <p></p>"},{"location":"demos/UE5%20Module%20Showcase/#support-data-structures","title":"Support Data Structures","text":"<p>In order to increase the compatibility and make the usage of the RCS module possible on the Blueprint system, it incorporates the <code>struct FServoInfo</code>, which combines the <code>uint8 servoId</code> and <code>uint8 servoPosition</code> information into a simple, Blueprint compatible data structure.</p> <p></p> <p>RCS also incorporates <code>enum ECLIErrorCode</code>, an enum listing the possible error codes returned by this module's functions. This code can be retrieved using the <code>GetErr()</code> Blueprint function, and filtered against an enum switch, simplifying error handling on UE Blueprints.</p>"},{"location":"demos/UE5%20Module%20Showcase/#rcs-demo","title":"RCS Demo","text":"<p>A brief video showcasing how the UE5 RemoteClientSystem can be used to operate the Youbionic Robot, in this case performing head rotation on each movement order.</p>"},{"location":"demos/UE5%20Module%20Showcase/#demo-blueprint-used","title":"Demo Blueprint used","text":"<p>The Blueprint used for the demo follows a simple logic: check the <code>ServoID=26</code> position, if it's greater than 90, set its value to zero; otherwise, if it's under 90, set it to 179. After this step, the movement order is sent to the server, which in turn makes the Youbionic Half perform the head rotation movement.</p>"}]}