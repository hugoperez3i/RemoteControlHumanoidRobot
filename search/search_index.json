{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"Telerobotic Platform:         Remote Control of a Humanoid Robot    <p>This project features an educational telerobotic platform designed for the remote operation of robots. It follows an orchestrator system architecture in which a central server receives commands from remote clients and routes them to the selected robot. </p> <p>Communications between nodes are handled through a custom, lightweight, application-layer protocol focused on clarity and functionality, minimizing overhead while remaining human-readable and easily extendable.</p> <p>The platform includes two client-side implementations. The first one is a fully developed JavaFX application, offering a streamlined graphical interface for direct robot control. The second is a custom Unreal Engine 5 module that seamlessly integrates into UE5 projects using a blueprint-friendly interface, enabling real-time robotic control from within Unreal-based projects.</p> <p>To sum it up:</p> <ul> <li>Orchestrator-based platform</li> <li>Lightweight, human-readable custom protocol</li> <li>JavaFX GUI Client</li> <li>UE5 Control module with native Blueprint integration</li> </ul> <p>This project merges the work of both my Telecommunications Systems Engineering and Biomedical Engineering bachelor\u2019s theses, combining system-level communications design with applied robotics in a single, complete platform.</p>"},{"location":"Application%20Protocol/Control%20Query/","title":"Control Query","text":"<p>_ACK / NACK</p>"},{"location":"Application%20Protocol/Execution%20Mode/","title":"Execution Mode","text":"<p>eMOD</p>"},{"location":"Application%20Protocol/Identification%20Query/","title":"Identification Query","text":"<p>client_here NodeMCU_here</p>"},{"location":"Application%20Protocol/MCU%20Information/","title":"MCU Information","text":"<p>iMCU</p>"},{"location":"Application%20Protocol/Protocol%20Definition/","title":"Protocol Definition","text":"<p>blahblah protocol</p> <pre><code>Persistent socket connection through TCP/IP\nplain raw binary - no codification\nport 54817\n</code></pre>"},{"location":"Application%20Protocol/Protocol%20Definition/#architecture-components","title":"Architecture Components","text":"<p>The protocol contemplates three types of nodes: client, server and mcu.</p> <ul> <li>Client: Refers to the remote user, which can control a mcu.</li> <li>Server: Refers to the orchestrator service, in charge of query validation and routing client queries to the indicated MCU. </li> <li>MCU: Refers to the remote robotic system, which may be remotely operated by a client.</li> </ul>"},{"location":"Application%20Protocol/Protocol%20Definition/#client-role","title":"Client Role","text":"<pre><code>heh TODO\n</code></pre>"},{"location":"Application%20Protocol/Protocol%20Definition/#server-role","title":"Server Role","text":"<pre><code>heh TODO\n</code></pre>"},{"location":"Application%20Protocol/Protocol%20Definition/#mcu-role","title":"MCU Role","text":"<pre><code>heh TODO\n</code></pre>"},{"location":"Application%20Protocol/Protocol%20Definition/#mcu-types","title":"MCU Types","text":"<p>The protocol contemplates two types of MCU robotic systems:</p> <ul> <li>SmartMCU: Refers to a mcu that is capable of generating its own PWM signal values for a given position. This means that a SmartMCU must be able to store locally the PWM calibration values, it also needs to be capable of storing pending movements, and will be required to, on connection, send the current position of each of its servos.</li> <li>DumbMCU: Refers to a mcu that executes movements by reading the PWM signal value directly from the query. This means that a DumbMCU will not receive any information until a movement is expected to be executed, at which point, it will receive a query with the PWM signal value for each servo, instead of a servo position (0\u00ba-179\u00ba). On connection, a DumbMCU is required to send the number of servos it has. </li> </ul>"},{"location":"Application%20Protocol/Protocol%20Definition/#no-binary-zero-convention","title":"No binary zero convention","text":"<p>In order to avoid potential issues with the zero-value bytes (<code>uint8_t b=0</code>), every numerical field that could possibly take the value zero gets offset by +1. This means that fields such as <code>servoId</code> (range 0-31) and <code>servoPosition</code> (range 0-179) will be sent with a +1 possitive offset applied: <code>servoId</code> would take the range (1-32) and <code>servoPosition</code> the range (1-180).</p>"},{"location":"Application%20Protocol/Protocol%20Definition/#protocol-query-format","title":"Protocol Query Format","text":"<p>The protocol distiguishes two types of query formats: A client - server format, and a server - mcu format. These two formats were defined to improve the clarity of the protocol, making it obvious which part of the communication chain a given query belongs to. However, the login query poses an exception to these formats, where client and mcu have a unique query style, also different from the other query formats.</p> <p>All characters used for query formatting, be it query structur</p>"},{"location":"Application%20Protocol/Protocol%20Definition/#client-server-query-format","title":"Client - Server Query Format","text":"<p>The message follows a set structure: it always starts with a constant header, <code>!s-</code>, followed by a 4-byte function selector code <code>CODE</code>, and is terminated by a constant tail <code>-e!</code>. This structure can accomodate aditional information, for those functions that require it: the information will be addded behind the four-byte function selector code (<code>CODE</code>), separated with an additional slash <code>-</code>.</p> No additional informationContaining additional information <pre><code>!s-CODE-e!\n</code></pre> <pre><code>!s-CODE-&lt;additional_information&gt;-e!\n</code></pre> <p>This means that the minimum query length will be <code>11</code> bytes (3 from the header <code>!s-</code>, +4 from the selection code <code>CODE</code>, and +3 from the tail sequence <code>-e!</code>). Any query with less than <code>11 bytes</code> can be safely deleted, as it would mean that some kind of error happened during query formation.</p>"},{"location":"Application%20Protocol/Protocol%20Definition/#server-mcu-query-format","title":"Server - MCU Query Format","text":"<p>Similarly to the client - server query, the server - mcu query also uses an structured format with header and tail. However, in this second format, the header is reduced to a single <code>-</code>, while the tail sequence takes the form <code>-!</code>. The 4-byte function selector code becomes a single-byte code <code>c</code>, and the additional information, when needed, is added in the exact same format as the client - server format: behind the single-byte code <code>c</code>, and separated with a dash character <code>-</code>.</p>"},{"location":"Application%20Protocol/Robot%20Selection/","title":"Robot Selection","text":"<p>sMCU</p>"},{"location":"Application%20Protocol/Server%20Shutdown/","title":"Server Shutdown","text":"<p>sOFF</p>"},{"location":"Application%20Protocol/Servo%20Movement/","title":"Servo Movement","text":"<p>SRVP</p>"},{"location":"Application%20Protocol/Upload%20Information/","title":"Upload Information","text":"<p>UINF</p>"},{"location":"License/License/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2025, Hugo P\u00e9rez.</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"License/License/#third-party-libraries-and-dependencies","title":"Third-Party Libraries and Dependencies","text":"<p>This project incorporates third-party libraries and images which are licensed under their respective terms.  The licenses for these libraries and images remain unchanged and must be adhered to when using or distributing this project. </p> <p>The third-party libraries used in this project include:</p> <ol> <li>SQLite - Public domain. https://sqlite.org/copyright.html</li> <li>Unreal Engine 5.5 - Licensed under the Unreal\u00ae Engine End User License Agreement. https://www.unrealengine.com/en-US/eula/unreal</li> <li>Java (JDK21) - Licensed under the GNU General Public License, version 2, with the Classpath Exception. https://openjdk.org/legal/gplv2+ce.html </li> <li>JavaFX - Licensed under the GNU General Public License v2.0. https://github.com/openjdk/jfx/blob/master/LICENSE</li> </ol> <p>Third-party icons sourced from https://game-icons.net/ (CC BY 3.0):  </p> <ul> <li>Artists: Lorc, sbed, Lord Berandas, Delapouite, et al.</li> <li>License: https://creativecommons.org/licenses/by/3.0/ </li> </ul>"},{"location":"demos/Demo%20Showcase/","title":"Demo Showcase: Scripted actions","text":"<p>A simple showcase of the telerobotic platform working, in which the Youbionic Half performs a scripted movement.</p>"},{"location":"demos/Demo%20Showcase/#showcase-video","title":"Showcase Video","text":""},{"location":"demos/Demo%20Showcase/#demo-walkthrough","title":"Demo walkthrough","text":"<p>This demo intends to show how the platform operates. For this task a simple client is used to control the Youbionic Half robot, and perform a series of scripted movements that resemble the action of looking towards your hand, open and close it, and get back to your original position.</p>"},{"location":"demos/Demo%20Showcase/#server-connection","title":"Server Connection","text":"<p>The first part of the cpp script, available on the next section, creates a client that connects to a given IP at the predefined port <code>57573</code>:</p> <pre><code>/* Start connection */\nClient c(ip);\n    usleep(500000);\n</code></pre>"},{"location":"demos/Demo%20Showcase/#robot-selection","title":"Robot Selection","text":"<p>Then the script selects the robot it wants to control, in this case Maroon - the ID used by the Youbionic Half robot in our setup, using the <code>connectToMCU()</code> function:</p> <pre><code>/* Select the mcu to control */\nstd::cout&lt;&lt;c.connectToMCU(\"Maroon\") &lt;&lt;\"\\n\";\n    usleep(2500000); // Wait 2.5 seconds\n</code></pre>"},{"location":"demos/Demo%20Showcase/#movement-configuration-and-execution","title":"Movement Configuration and Execution","text":"<p>For each movement, the client needs to generate a <code>std::vector&lt;int&gt;</code> in which to store the desired movements. For this client implementation, a <code>uint32_t flag</code> bitmask is also needed. This flag serves as an efficient way of indicating <code>moveServos()</code> the IDs of the servos that we want to move.</p> <p><pre><code>/* Combined movement 1 - Rise hand towards face, tilt head */\nstd::vector&lt;int&gt; pV1;{\n    flag=0;\n    pV1.push_back(0); // rotate palm towards face\n    flag = (flag | (1&lt;&lt;13)); \n    pV1.push_back(0); // flex arm towards face\n    flag = (flag | (1&lt;&lt;15)); \n    pV1.push_back(100); // Rotate arm towards body\n    flag = (flag | (1&lt;&lt;17)); \n    pV1.push_back(179); // Tilt head towards hand\n    flag = (flag | (1&lt;&lt;25)); \n    pV1.push_back(141); // Rotate head towards hand\n    flag = (flag | (1&lt;&lt;26)); \n}\n</code></pre> Lastly, the <code>moveServos()</code> function is used to send the movement order to the server, which will validate it and provide a two-step response (assuming it passes validation). The first ACK will be \"intercepted\" by <code>moveServos()</code>, which confirms that the order is valid, and that it will be sent to the robot for execution. The second response is read by the <code>readServerResponse()</code>, and it corresponds to the movement confirmation by the robot MCU.</p> <pre><code>std::cout&lt;&lt;c.moveServos(flag,pV1) &lt;&lt;\" - Servo movemet confirmation\\n\";\nstd::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n    usleep(1500000); // Wait 1.5 seconds\n</code></pre> <p>After every code section, the function <code>usleep()</code> is used to introduce a delay between instructions. While during normal usage this might not be required, in this script it comes in handy to force a minor pause between each block execution - making the individual movements much more obvious and deliberate.</p>"},{"location":"demos/Demo%20Showcase/#code-for-the-demo","title":"Code for the Demo","text":"<p>Below is the main.cpp used for the demo. The complete source files for the client can be found in the TestClient dir of this github repo.</p> main.cpp<pre><code>#include \"Client.h\"\n\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;unistd.h&gt;\n\n\nint main(int argc, char const *argv[]){\n\n    uint32_t flag=0;\n\n    /* Start connection */\n    Client c(ip);\n        usleep(500000);\n\n    /* Select the mcu to control */\n    std::cout&lt;&lt;c.connectToMCU(\"Maroon\") &lt;&lt;\"\\n\";\n        usleep(2500000); // Wait 2.5 seconds\n\n\n    /* Combined movement 1 - Rise hand towards face, tilt head */\n    std::vector&lt;int&gt; pV1;{\n        flag=0;\n        pV1.push_back(0); // rotate palm towards face\n        flag = (flag | (1&lt;&lt;13)); \n        pV1.push_back(0); // flex arm towards face\n        flag = (flag | (1&lt;&lt;15)); \n        pV1.push_back(100); // Rotate arm towards body\n        flag = (flag | (1&lt;&lt;17)); \n        pV1.push_back(179); // Tilt head towards hand\n        flag = (flag | (1&lt;&lt;25)); \n        pV1.push_back(141); // Rotate head towards hand\n        flag = (flag | (1&lt;&lt;26)); \n    }\n    std::cout&lt;&lt;c.moveServos(flag,pV1) &lt;&lt;\" - Servo movemet comprobation\\n\";\n    std::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n        usleep(1500000); // Wait 1.5 seconds\n\n    /* Combined movement 3 - Close hand */\n    std::vector&lt;int&gt; pV3;{\n        flag=0;\n        pV3.push_back(0); // Thumb\n        flag = (flag | (1&lt;&lt;6)); \n        pV3.push_back(0); // Index\n        flag = (flag | (1&lt;&lt;7)); \n        pV3.push_back(0); // Middle\n        flag = (flag | (1&lt;&lt;8)); \n        pV3.push_back(0); // Ring\n        flag = (flag | (1&lt;&lt;9)); \n        pV3.push_back(0); // Little\n        flag = (flag | (1&lt;&lt;10));     }\n    std::cout&lt;&lt;c.moveServos(flag,pV3) &lt;&lt;\" - Servo movemet comprobation\\n\";\n    std::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n        usleep(1500000); // Wait 1.5 seconds\n\n    /* Combined movement 4 - rest hand */\n    std::vector&lt;int&gt; pV4;{\n        flag=0;\n        pV4.push_back(90); // Thumb\n        flag = (flag | (1&lt;&lt;6)); \n        pV4.push_back(90); // Index\n        flag = (flag | (1&lt;&lt;7)); \n        pV4.push_back(90); // Middle\n        flag = (flag | (1&lt;&lt;8)); \n        pV4.push_back(90); // Ring\n        flag = (flag | (1&lt;&lt;9)); \n        pV4.push_back(90); // Little\n        flag = (flag | (1&lt;&lt;10)); \n    }\n    std::cout&lt;&lt;c.moveServos(flag,pV4) &lt;&lt;\" - Servo movemet comprobation\\n\";\n    std::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n        usleep(1500000); // Wait 1.5 seconds\n\n    /* Combined movement 5 - Move arm and head back to \"resting\" position */\n    std::vector&lt;int&gt; pV5;{\n        flag=0;\n        pV5.push_back(90); // rotate palm towards face\n        flag = (flag | (1&lt;&lt;13)); \n        pV5.push_back(60); // flex arm towards face\n        flag = (flag | (1&lt;&lt;15)); \n        pV5.push_back(70); // Rotate arm towards body\n        flag = (flag | (1&lt;&lt;17)); \n        pV5.push_back(126); // Tilt head towards hand\n        flag = (flag | (1&lt;&lt;25)); \n        pV5.push_back(100); // Rotate head towards hand\n        flag = (flag | (1&lt;&lt;26)); \n    }\n    std::cout&lt;&lt;c.moveServos(flag,pV5) &lt;&lt;\" - Servo movemet comprobation\\n\";\n    std::cout&lt;&lt;c.readServerResponse() &lt;&lt;\" - MCU confirmation of movement\\n\";\n        usleep(2500000); // Wait 2.5 seconds\n\n}\n</code></pre>"},{"location":"demos/Platform%20Showcase/","title":"Full Platform Showcase","text":"<p>A demo of the full platform, where the Youbionic Half is controlled via the JavaFX client, performing arm flexion and head rotation.</p> <p></p>"},{"location":"demos/Platform%20Showcase/#platform-components","title":"Platform components","text":"<p>The platform consists of three parts:</p> <ul> <li>Robotic system: The Youbionic half and the power supplies that power it.</li> <li>Server: A computer acting both as server and Wi-Fi Access Point (AP).</li> <li>Client: The laptop is used to run the JavaFX client application and remotely operate the robot. In this demo, it is also used to view the MCU's verbose log, as well as powering the MCU. </li> </ul> Youbionic HalfServerVerbose serial log (MCU) <p></p> <p></p> <p></p>"},{"location":"demos/Platform%20Showcase/#power-requirements","title":"Power requirements","text":"<p>While a proper power consumption study has not been conducted, the servos used by the robotic system do have a fluctuating power draw of 0.72 amps to 0.96 amps at idle. For this reason, the robot is currently hooked up to two DC power supplies, each capable of providing up to 3A@5V. This allows for normal operation of the robot, although the ideal configuration would use a single, high-amp DC power supply at 6 volts.</p> <p>Note that power usage depends on the robotic system's servo configuration, so this observation only applies to those using the same robotic platform and servo combination.</p>"},{"location":"demos/Platform%20Showcase/#wi-fi-connectivity","title":"Wi-Fi Connectivity","text":"<p>The computer acting as server, a Win10 machine, is also used to host the Wi-Fi network that the MCU will connect to. This is achieved by using Windows Mobile hotspot functionality, which allows a computer to share its current internet connection as a hosted Wi-Fi network. Since there's no port forwarding configured, remote operation from outside the networks the server is connected to is impossible.</p> <p>Port Forwarding</p> <p>The server has no login authentication, no encryption and, while it attempts to discard invalid queries, it makes no assurances that all malicious queries will be discarded. As such, it is not recommended to set up a direct or transparent port forward. Doing so will risk your computer and, at that point, you're on your own. </p> <p>If port forwarding is desired, it should be done so through a proxy gateway that enforces some kind of log-in/authentication, traffic filtering or rate-limiting policies, to avoid potential risk to the computer hosting the server.</p>"},{"location":"demos/Platform%20Showcase/#demo-video","title":"Demo Video","text":"<p>Brief demonstration of how the JavaFX application can be used to remotely operate the Youbionic Half. As seen in the video, the delay is almost imperceptible.</p>"},{"location":"demos/UE5%20Module%20Showcase/","title":"UE5 Module Showcase: RemoteClientSystem","text":"<p>This demo intends to show the RemoteClientSystem (RCS) module developed to incorporate this platform's controls into the Unreal Engine 5 ecosystem. </p>"},{"location":"demos/UE5%20Module%20Showcase/#function-suite","title":"Function Suite","text":"<p>The RCS module abstracts the platform communication protocols into a set of Blueprint-friendly functions that make possible integration of the platform robot interface into Unreal's scripting system.</p> <p></p>"},{"location":"demos/UE5%20Module%20Showcase/#support-data-structures","title":"Support Data Structures","text":"<p>In order to increase the compatibility and make the usage of the RCS module on the Blueprint system, it incorporates the <code>struct FServoInfo</code>, which combines the <code>uint8 servoId</code> and <code>uint8 servoPosition</code> information into a simple, Blueprint compatible data structure.</p> <p></p> <p>RCS also incorporates <code>enum ECLIErrorCode</code>, an enum listing the possible error codes returned by this module's functions. This code can be retrieved using the <code>GetErr()</code> Blueprint function, and filtered against an enum switch, simplifying error handling on UE Blueprints.</p>"},{"location":"demos/UE5%20Module%20Showcase/#rcs-demo","title":"RCS Demo","text":"<p>A brief video showcasing how the UE5 RemoteClientSystem can be used to operate the Youbionic Robot, in this case performing head rotation on each movement order.</p>"},{"location":"demos/UE5%20Module%20Showcase/#demo-blueprint-used","title":"Demo Blueprint used","text":"<p>The Blueprint used for the demo follows a simple logic: check the <code>ServoID=26</code> position, if it's greater than 90, set its value to zero; otherwise, if it's under 90, set it to 179. After this step, the movement order is sent to the server, which in turn makes the Youbionic Half perform the head rotation movement.</p>"}]}